-- MySQL dump 10.13  Distrib 8.0.22, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: blog
-- ------------------------------------------------------
-- Server version	8.0.22

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `admin`
--

DROP TABLE IF EXISTS `admin`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `admin` (
  `username` text,
  `password` text,
  `id` int NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `admin`
--

LOCK TABLES `admin` WRITE;
/*!40000 ALTER TABLE `admin` DISABLE KEYS */;
INSERT INTO `admin` (`username`, `password`, `id`) VALUES ('admin','123456',1);
/*!40000 ALTER TABLE `admin` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '文章ID',
  `title` varchar(255) DEFAULT NULL COMMENT '文章标题',
  `introduce` text COMMENT '文章简介',
  `article_content` longtext COMMENT '文章内容',
  `addTime` int DEFAULT NULL COMMENT '添加时间',
  `article_content_html` longtext COMMENT '文章内容html形式',
  `introduce_html` text COMMENT '文章简介的html形式',
  `isTop` int DEFAULT '0' COMMENT '文章是否置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` (`id`, `title`, `introduce`, `article_content`, `addTime`, `article_content_html`, `introduce_html`, `isTop`) VALUES (8,'ViewPager使用App引导页面','ViewPager使用App引导页面','> 相关代码已经上传到[仓库](https://github.com/13531982270/BlogDemo2)的ViewPager文件夹内\n\n\n![viewPager实现引导页面.gif](https://upload-images.jianshu.io/upload_images/4002920-43564c3f9797995c.gif?imageMogr2/auto-orient/strip)\n\n\n> 项目的基础配置就不多做赘述了，不清楚的可以查看我的这篇[文章](https://www.jianshu.com/p/186eab810e10)。\n\n![结构目录.png](https://upload-images.jianshu.io/upload_images/4002920-ac184603b6d01d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n> 页面是由8张图片组成的，分别是4张透明背景的文字图片和4张黑底的图片图片\n\n![图片素材.png](https://upload-images.jianshu.io/upload_images/4002920-42a31d19b42624f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n#### 文字滑动\n\n> 在module包下创建guide包，创建GuideActivity\n\n```\nimport kotlinx.android.synthetic.main.activity_guide.*\n/**\n * 引导页面\n */\nclass GuideActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_guide)\n    }\n}\n```\n\n**1)** 创建res-drawable-hdpi文件夹，这一步很关键，因为我们的素材文件有点大，如果不放在hdpi文件夹，而是放在普通的drawable文件夹内的话很可能会出现OOM内存溢出异常.\n\n**2)** 把我们的4张文字图片和4张图标素材拷到文件夹内\n\n**3)** 书写activity_guide.xml文件\n\n```kotlin\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\".module.guide.GuideActivity\">\n\n    <!--用来显示图标图片-->\n    <ImageView\n        android:id=\"@+id/mImageViews\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n\n    <!--用来显示文字图片，其实我们滑动的仅仅是文字图片而已，后面的图标变化是我们去监听文字图片的滑动位置再去设置改变的-->\n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/mViewPager\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n    </android.support.v4.view.ViewPager>\n\n</android.support.constraint.ConstraintLayout>\n```\n\n> 回到GuideActivity\n\n```kotlin\nimport kotlinx.android.synthetic.main.activity_guide.*\n\n/**\n * 引导页面\n */\nclass GuideActivity : WinActivity() {\n\n    //滑动文字图片的int数组\n    var ids = intArrayOf(R.drawable.guide_txt_a, R.drawable.guide_txt_b, R.drawable.guide_txt_c, R.drawable.guide_txt_d)\n\n    //用来填充viewPager的ImageView集合\n    private val imageViews = ArrayList<ImageView>()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_guide)\n        //初始化数据\n        initData()\n    }\n\n    /**\n     * 初始化数据\n     */\n    private fun initData() {\n        //遍历ids数组，把ids数据的图片路径传到imageViews集合中\n        for (i in ids.indices) {\n            //通过代码生成ImageView\n            val imageView = ImageView(this)\n            //设置生成的ImageView的背景\n            imageView.setBackgroundResource(ids[i])\n            //将设置好的ImageView添加到集合中\n            imageViews.add(imageView)\n        }\n        //设置ViewPager适配器\n        mViewPager.adapter = MyAdapter()\n    }\n\n    /**\n     * 设置viewPager适配器\n     * 这里记得把MyAdapter加上inner关键字，声明为内部类\n     */\n    inner class MyAdapter : PagerAdapter() {\n\n        override fun isViewFromObject(view: View, `object`: Any): Boolean {\n            return view == `object`\n        }\n\n        /**\n         * 返回数据中的中个数\n         */\n        override fun getCount(): Int {\n            return imageViews.size\n        }\n\n        override fun instantiateItem(container: ViewGroup, position: Int): Any {\n            var imageView: ImageView = imageViews.get(position)\n            //添加到容器中\n            container.addView(imageView)\n            return imageView\n        }\n\n        override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {\n//            super.destroyItem(container, position, `object`)\n            container.removeView(`object` as View?)\n        }\n    }\n}\n```\n\n**1）**我们声明了Int类型数组，该数组是用来存储要显示的文字图片的。还声明了泛形为ImageView类型的imageViews集合，该集合是用来存储我们要填充到viewPager上的ImageView的，\n\n**2）**之后我们通过for循环把int数组的图片都设置到通过代码生成的ImageView里，并把这些生成的图片都填充到imageViews集合里。\n\n**3）**最后设置viewPager的适配器，数据源就是我们处理后的imageViews集合\n\n![文字图片滑动.gif](https://upload-images.jianshu.io/upload_images/4002920-ce8a357ed7d0248e.gif?imageMogr2/auto-orient/strip)\n\n\n\n\n####图标变化\n\n> 中间图标的变化的实现方式是我们去监听viewPager的滑动情况，当监听到进入下一个页面时，去设置相应的图片\n\n```kotlin\n /**\n   * 初始化数据\n   */\n   private fun initData() {\n        //viewPager滑动监听\n        mViewPager.addOnPageChangeListener(MyOnPageChangeListener())\n       //...其它不变\n    }\n\n```\n\n```kotlin\n/**\n * 监听ViewPager的滑动距离\n */\ninner class MyOnPageChangeListener : ViewPager.OnPageChangeListener {\n\n    override fun onPageScrollStateChanged(state: Int) {\n    }\n\n    /**\n     * 当页面滚动时\n     * @param position 当前滑动页面的位置\n     */\n    override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {\n        L.d(\"当前页面的位置:$position\")\n        when (position) {\n            0 -> mImageViews.setImageResource(R.drawable.guide_img_a)\n            1 -> mImageViews.setImageResource(R.drawable.guide_img_b)\n            2 -> mImageViews.setImageResource(R.drawable.guide_img_c)\n            3 -> mImageViews.setImageResource(R.drawable.guide_img_d)\n        }\n    }\n\n    override fun onPageSelected(position: Int) {\n\n    }\n}\n```\n\n![图标滑动.gif](https://upload-images.jianshu.io/upload_images/4002920-61346ae32bb4cb2e.gif?imageMogr2/auto-orient/strip)\n\n> 完整代码\n\n```kotlin\nimport kotlinx.android.synthetic.main.activity_guide.*\nimport java.util.ArrayList\n\n/**\n * 引导页面\n */\nclass GuideActivity : WinActivity() {\n\n    //用来填充布局的ImagView集合\n    private val imageViews = ArrayList<ImageView>()\n\n    //图片数据\n    internal var ids = intArrayOf(R.drawable.guide_txt_a, R.drawable.guide_txt_b, R.drawable.guide_txt_c, R.drawable.guide_txt_d)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_guide)\n        //初始化数据\n        initData()\n    }\n\n    /**\n     * 初始化数据\n     */\n    private fun initData() {\n        //viewPager滑动监听\n        mViewPager.addOnPageChangeListener(MyOnPageChangeListener())\n        //将图片添加到集合中\n        for (i in ids.indices) {\n            //          通过代码生成ImageView\n            val imageView = ImageView(this)\n            //          设置imageView背景\n            imageView.setBackgroundResource(ids[i])\n            //          将生成的imagView添加到集合中去\n            imageViews.add(imageView)\n        }\n        //设置viewPager适配器\n        mViewPager.adapter = MyAdapter()\n    }\n\n    /**\n     * 监听ViewPager的滑动距离\n     */\n    inner class MyOnPageChangeListener : ViewPager.OnPageChangeListener {\n\n        override fun onPageScrollStateChanged(state: Int) {\n        }\n\n        /**\n         * 当页面滚动时\n         * @param position 当前滑动页面的位置\n         */\n        override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {\n            L.d(\"当前页面的位置:$position\")\n            when (position) {\n                0 -> mImageViews.setImageResource(R.drawable.guide_img_a)\n                1 -> mImageViews.setImageResource(R.drawable.guide_img_b)\n                2 -> mImageViews.setImageResource(R.drawable.guide_img_c)\n                3 -> mImageViews.setImageResource(R.drawable.guide_img_d)\n            }\n        }\n\n        override fun onPageSelected(position: Int) {\n\n        }\n    }\n\n    /**\n     * ViewPager适配器\n     */\n    inner class MyAdapter : PagerAdapter() {\n        /**\n         * 返回数据中的总个数\n         */\n        override fun getCount(): Int {\n            return imageViews.size\n        }\n\n        override fun isViewFromObject(view: View, `object`: Any): Boolean {\n            return view == `object`\n        }\n\n        /**\n         * 将数据添加到集合中\n         */\n        override fun instantiateItem(container: ViewGroup, position: Int): Any {\n            var imageView: ImageView = imageViews.get(position);\n            //添加到容器中\n            container.addView(imageView)\n            return imageView\n        }\n\n        /**\n         * 销毁识图\n         */\n        override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {\n//            super.destroyItem(container, position, `object`)\n            container.removeView(`object` as View?)\n        }\n    }\n}\n```\n\n#### 按钮和文字\n\n> 在drawable文件夹内创建guide_button.xml，用来设置按钮的背景\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!--相当于做了一张圆角的图片,然后给button作为背景图片-->\n<shape xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:shape=\"rectangle\">\n    <!--设置背景色-->\n    <solid android:color=\"#24C68A\" />\n    <!--设置圆角-->\n    <corners android:radius=\"305dp\" />\n    <!--<padding-->\n    <!--android:bottom=\"10dp\"-->\n    <!--android:left=\"10dp\"-->\n    <!--android:right=\"10dp\"-->\n    <!--android:top=\"10dp\"-->\n    <!--/>-->\n    <!--设置边框线的宽度和颜色-->\n    <stroke android:width=\"1dp\" android:color=\"#24C68A\" />\n</shape>\n```\n\n> 最后在xml布局把按钮和文字写上\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:background=\"@android:color/black\"\n    tools:context=\".module.guide.GuideActivity\">\n\n    <!--用来显示图标图片-->\n    <ImageView\n        android:id=\"@+id/mImageViews\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" />\n\n    <!--用来显示文字图片，其实我们滑动的仅仅是文字图片而已，后面的图标变化是我们去监听文字图片的滑动位置再去设置改变的-->\n    <android.support.v4.view.ViewPager\n        android:id=\"@+id/mViewPager\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n    </android.support.v4.view.ViewPager>\n\n    <!-- app:layout_constraintBottom_toBottomOf=\"parent\" 控件自身的底部与父控件的底部对齐-->\n    <Button\n        android:id=\"@+id/mRegister\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"49dp\"\n        android:layout_marginBottom=\"58dp\"\n        android:layout_marginLeft=\"34dp\"\n        android:layout_marginRight=\"34dp\"\n        android:background=\"@drawable/guide_button\"\n        android:padding=\"8dp\"\n        android:text=\"现在就加入\"\n        android:textColor=\"#ffffff\"\n        android:textSize=\"16sp\"\n        app:layout_constraintBottom_toBottomOf=\"parent\" />\n\n    <!-- app:layout_constraintRight_toRightOf=\"parent\" 控件自身的右边与父控件的右边对齐-->\n    <!--  app:layout_constraintTop_toTopOf=\"parent\" 控件自身的顶部与控件的顶部对齐-->\n    <TextView\n        android:id=\"@+id/mTxtLogin\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_marginRight=\"10dp\"\n        android:layout_marginTop=\"12dp\"\n        android:text=\"登陆\"\n        android:textColor=\"@android:color/white\"\n        android:textSize=\"16sp\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n</android.support.constraint.ConstraintLayout>\n```\n\n> 结束\n\n> 关于本文所述，也不知道对不对。如果有做得不够好的地方，请直接指出，见笑了。',1629993600,'<blockquote>\n<p>相关代码已经上传到<a href=\"https://github.com/13531982270/BlogDemo2\">仓库</a>的ViewPager文件夹内</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-43564c3f9797995c.gif?imageMogr2/auto-orient/strip\" alt=\"viewPager实现引导页面.gif\"></p>\n<blockquote>\n<p>项目的基础配置就不多做赘述了，不清楚的可以查看我的这篇<a href=\"https://www.jianshu.com/p/186eab810e10\">文章</a>。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-ac184603b6d01d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结构目录.png\"></p>\n<blockquote>\n<p>页面是由8张图片组成的，分别是4张透明背景的文字图片和4张黑底的图片图片</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-42a31d19b42624f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片素材.png\"></p>\n<a id=\"toc41\" href=\"#toc41\" class=\"anchor-fix\"><h4>文字滑动</h4></a>\n<blockquote>\n<p>在module包下创建guide包，创建GuideActivity</p>\n</blockquote>\n<pre><code>import kotlinx.android.synthetic.main.activity_guide.*\n/**\n * 引导页面\n */\nclass GuideActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_guide)\n    }\n}</code></pre><p><strong>1)</strong> 创建res-drawable-hdpi文件夹，这一步很关键，因为我们的素材文件有点大，如果不放在hdpi文件夹，而是放在普通的drawable文件夹内的话很可能会出现OOM内存溢出异常.</p>\n<p><strong>2)</strong> 把我们的4张文字图片和4张图标素材拷到文件夹内</p>\n<p><strong>3)</strong> 书写activity_guide.xml文件</p>\n<pre><code class=\"language-kotlin\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;\n    tools:context=&quot;.module.guide.GuideActivity&quot;&gt;\n\n    &lt;!--用来显示图标图片--&gt;\n    &lt;ImageView\n        android:id=&quot;@+id/mImageViews&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n\n    &lt;!--用来显示文字图片，其实我们滑动的仅仅是文字图片而已，后面的图标变化是我们去监听文字图片的滑动位置再去设置改变的--&gt;\n    &lt;android.support.v4.view.ViewPager\n        android:id=&quot;@+id/mViewPager&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;/android.support.v4.view.ViewPager&gt;\n\n&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre>\n<blockquote>\n<p>回到GuideActivity</p>\n</blockquote>\n<pre><code class=\"language-kotlin\">import kotlinx.android.synthetic.main.activity_guide.*\n\n/**\n * 引导页面\n */\nclass GuideActivity : WinActivity() {\n\n    //滑动文字图片的int数组\n    var ids = intArrayOf(R.drawable.guide_txt_a, R.drawable.guide_txt_b, R.drawable.guide_txt_c, R.drawable.guide_txt_d)\n\n    //用来填充viewPager的ImageView集合\n    private val imageViews = ArrayList&lt;ImageView&gt;()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_guide)\n        //初始化数据\n        initData()\n    }\n\n    /**\n     * 初始化数据\n     */\n    private fun initData() {\n        //遍历ids数组，把ids数据的图片路径传到imageViews集合中\n        for (i in ids.indices) {\n            //通过代码生成ImageView\n            val imageView = ImageView(this)\n            //设置生成的ImageView的背景\n            imageView.setBackgroundResource(ids[i])\n            //将设置好的ImageView添加到集合中\n            imageViews.add(imageView)\n        }\n        //设置ViewPager适配器\n        mViewPager.adapter = MyAdapter()\n    }\n\n    /**\n     * 设置viewPager适配器\n     * 这里记得把MyAdapter加上inner关键字，声明为内部类\n     */\n    inner class MyAdapter : PagerAdapter() {\n\n        override fun isViewFromObject(view: View, `object`: Any): Boolean {\n            return view == `object`\n        }\n\n        /**\n         * 返回数据中的中个数\n         */\n        override fun getCount(): Int {\n            return imageViews.size\n        }\n\n        override fun instantiateItem(container: ViewGroup, position: Int): Any {\n            var imageView: ImageView = imageViews.get(position)\n            //添加到容器中\n            container.addView(imageView)\n            return imageView\n        }\n\n        override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {\n//            super.destroyItem(container, position, `object`)\n            container.removeView(`object` as View?)\n        }\n    }\n}</code></pre>\n<p><strong>1）</strong>我们声明了Int类型数组，该数组是用来存储要显示的文字图片的。还声明了泛形为ImageView类型的imageViews集合，该集合是用来存储我们要填充到viewPager上的ImageView的，</p>\n<p><strong>2）</strong>之后我们通过for循环把int数组的图片都设置到通过代码生成的ImageView里，并把这些生成的图片都填充到imageViews集合里。</p>\n<p><strong>3）</strong>最后设置viewPager的适配器，数据源就是我们处理后的imageViews集合</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-ce8a357ed7d0248e.gif?imageMogr2/auto-orient/strip\" alt=\"文字图片滑动.gif\"></p>\n<p>####图标变化</p>\n<blockquote>\n<p>中间图标的变化的实现方式是我们去监听viewPager的滑动情况，当监听到进入下一个页面时，去设置相应的图片</p>\n</blockquote>\n<pre><code class=\"language-kotlin\"> /**\n   * 初始化数据\n   */\n   private fun initData() {\n        //viewPager滑动监听\n        mViewPager.addOnPageChangeListener(MyOnPageChangeListener())\n       //...其它不变\n    }\n</code></pre>\n<pre><code class=\"language-kotlin\">/**\n * 监听ViewPager的滑动距离\n */\ninner class MyOnPageChangeListener : ViewPager.OnPageChangeListener {\n\n    override fun onPageScrollStateChanged(state: Int) {\n    }\n\n    /**\n     * 当页面滚动时\n     * @param position 当前滑动页面的位置\n     */\n    override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {\n        L.d(&quot;当前页面的位置:$position&quot;)\n        when (position) {\n            0 -&gt; mImageViews.setImageResource(R.drawable.guide_img_a)\n            1 -&gt; mImageViews.setImageResource(R.drawable.guide_img_b)\n            2 -&gt; mImageViews.setImageResource(R.drawable.guide_img_c)\n            3 -&gt; mImageViews.setImageResource(R.drawable.guide_img_d)\n        }\n    }\n\n    override fun onPageSelected(position: Int) {\n\n    }\n}</code></pre>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-61346ae32bb4cb2e.gif?imageMogr2/auto-orient/strip\" alt=\"图标滑动.gif\"></p>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<pre><code class=\"language-kotlin\">import kotlinx.android.synthetic.main.activity_guide.*\nimport java.util.ArrayList\n\n/**\n * 引导页面\n */\nclass GuideActivity : WinActivity() {\n\n    //用来填充布局的ImagView集合\n    private val imageViews = ArrayList&lt;ImageView&gt;()\n\n    //图片数据\n    internal var ids = intArrayOf(R.drawable.guide_txt_a, R.drawable.guide_txt_b, R.drawable.guide_txt_c, R.drawable.guide_txt_d)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_guide)\n        //初始化数据\n        initData()\n    }\n\n    /**\n     * 初始化数据\n     */\n    private fun initData() {\n        //viewPager滑动监听\n        mViewPager.addOnPageChangeListener(MyOnPageChangeListener())\n        //将图片添加到集合中\n        for (i in ids.indices) {\n            //          通过代码生成ImageView\n            val imageView = ImageView(this)\n            //          设置imageView背景\n            imageView.setBackgroundResource(ids[i])\n            //          将生成的imagView添加到集合中去\n            imageViews.add(imageView)\n        }\n        //设置viewPager适配器\n        mViewPager.adapter = MyAdapter()\n    }\n\n    /**\n     * 监听ViewPager的滑动距离\n     */\n    inner class MyOnPageChangeListener : ViewPager.OnPageChangeListener {\n\n        override fun onPageScrollStateChanged(state: Int) {\n        }\n\n        /**\n         * 当页面滚动时\n         * @param position 当前滑动页面的位置\n         */\n        override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {\n            L.d(&quot;当前页面的位置:$position&quot;)\n            when (position) {\n                0 -&gt; mImageViews.setImageResource(R.drawable.guide_img_a)\n                1 -&gt; mImageViews.setImageResource(R.drawable.guide_img_b)\n                2 -&gt; mImageViews.setImageResource(R.drawable.guide_img_c)\n                3 -&gt; mImageViews.setImageResource(R.drawable.guide_img_d)\n            }\n        }\n\n        override fun onPageSelected(position: Int) {\n\n        }\n    }\n\n    /**\n     * ViewPager适配器\n     */\n    inner class MyAdapter : PagerAdapter() {\n        /**\n         * 返回数据中的总个数\n         */\n        override fun getCount(): Int {\n            return imageViews.size\n        }\n\n        override fun isViewFromObject(view: View, `object`: Any): Boolean {\n            return view == `object`\n        }\n\n        /**\n         * 将数据添加到集合中\n         */\n        override fun instantiateItem(container: ViewGroup, position: Int): Any {\n            var imageView: ImageView = imageViews.get(position);\n            //添加到容器中\n            container.addView(imageView)\n            return imageView\n        }\n\n        /**\n         * 销毁识图\n         */\n        override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) {\n//            super.destroyItem(container, position, `object`)\n            container.removeView(`object` as View?)\n        }\n    }\n}</code></pre>\n<a id=\"toc42\" href=\"#toc42\" class=\"anchor-fix\"><h4>按钮和文字</h4></a>\n<blockquote>\n<p>在drawable文件夹内创建guide_button.xml，用来设置按钮的背景</p>\n</blockquote>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;\n&lt;!--相当于做了一张圆角的图片,然后给button作为背景图片--&gt;\n&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:shape=&quot;rectangle&quot;&gt;\n    &lt;!--设置背景色--&gt;\n    &lt;solid android:color=&quot;#24C68A&quot; /&gt;\n    &lt;!--设置圆角--&gt;\n    &lt;corners android:radius=&quot;305dp&quot; /&gt;\n    &lt;!--&lt;padding--&gt;\n    &lt;!--android:bottom=&quot;10dp&quot;--&gt;\n    &lt;!--android:left=&quot;10dp&quot;--&gt;\n    &lt;!--android:right=&quot;10dp&quot;--&gt;\n    &lt;!--android:top=&quot;10dp&quot;--&gt;\n    &lt;!--/&gt;--&gt;\n    &lt;!--设置边框线的宽度和颜色--&gt;\n    &lt;stroke android:width=&quot;1dp&quot; android:color=&quot;#24C68A&quot; /&gt;\n&lt;/shape&gt;</code></pre><blockquote>\n<p>最后在xml布局把按钮和文字写上</p>\n</blockquote>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:background=&quot;@android:color/black&quot;\n    tools:context=&quot;.module.guide.GuideActivity&quot;&gt;\n\n    &lt;!--用来显示图标图片--&gt;\n    &lt;ImageView\n        android:id=&quot;@+id/mImageViews&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot; /&gt;\n\n    &lt;!--用来显示文字图片，其实我们滑动的仅仅是文字图片而已，后面的图标变化是我们去监听文字图片的滑动位置再去设置改变的--&gt;\n    &lt;android.support.v4.view.ViewPager\n        android:id=&quot;@+id/mViewPager&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;match_parent&quot;&gt;\n\n    &lt;/android.support.v4.view.ViewPager&gt;\n\n    &lt;!-- app:layout_constraintBottom_toBottomOf=&quot;parent&quot; 控件自身的底部与父控件的底部对齐--&gt;\n    &lt;Button\n        android:id=&quot;@+id/mRegister&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;49dp&quot;\n        android:layout_marginBottom=&quot;58dp&quot;\n        android:layout_marginLeft=&quot;34dp&quot;\n        android:layout_marginRight=&quot;34dp&quot;\n        android:background=&quot;@drawable/guide_button&quot;\n        android:padding=&quot;8dp&quot;\n        android:text=&quot;现在就加入&quot;\n        android:textColor=&quot;#ffffff&quot;\n        android:textSize=&quot;16sp&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;\n\n    &lt;!-- app:layout_constraintRight_toRightOf=&quot;parent&quot; 控件自身的右边与父控件的右边对齐--&gt;\n    &lt;!--  app:layout_constraintTop_toTopOf=&quot;parent&quot; 控件自身的顶部与控件的顶部对齐--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/mTxtLogin&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_marginRight=&quot;10dp&quot;\n        android:layout_marginTop=&quot;12dp&quot;\n        android:text=&quot;登陆&quot;\n        android:textColor=&quot;@android:color/white&quot;\n        android:textSize=&quot;16sp&quot;\n        app:layout_constraintRight_toRightOf=&quot;parent&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;\n&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><blockquote>\n<p>结束</p>\n</blockquote>\n<blockquote>\n<p>关于本文所述，也不知道对不对。如果有做得不够好的地方，请直接指出，见笑了。</p>\n</blockquote>\n','<p>ViewPager使用App引导页面</p>\n',0),(9,'Android自定义评View实例教程~自定义可拖拽进度条「完全自定义」','Android自定义评View实例教程~自定义可拖拽进度条','> 实际效果，我们可以通过拖拽来设置进度，也可以通过点击按钮来设置进度\n\n![最终效果.gif](https://upload-images.jianshu.io/upload_images/4002920-87b9f10a596cf37a.gif?imageMogr2/auto-orient/strip)\n\n\n\n> 视频转Git会有卡顿感，实际运行并不会，项目源代码已经上传到[仓库](https://github.com/13531982270/BlogDemo4)的AProgress文件夹，\n>\n> 要看懂本篇文章，需要你掌握Paint类，Canvas类的基本使用，可以查看以下文章学习\n\n- [随风飘扬的微笑](https://www.jianshu.com/p/d86ea15dfdd2)\n\n> 该教程分为两个部分\n\n- [自定义可拖拽评价进度条一](https://www.jianshu.com/p/a0b6f171b872)\n- [自定义可拖拽评价进度条二](https://www.jianshu.com/p/975fe34c7c27)\n\n\n\n#### 触摸改变进度条的进度\n\n> 我们创建EasyProgress，继承于View，纯手工的来绘制Progress。\n\n![灰色.png](https://upload-images.jianshu.io/upload_images/4002920-13d7178a88c43420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n> 声明两个Paint变量，我们需要一个画笔来绘制一条总长度的线段，颜色为灰色。另外一个画笔来绘制实际选中长度的线段，颜色为绿色。\n>\n> 当我们的进度改变时，只需要将实际进度（绿色）的线段长度扩大，去覆盖灰色（背景）的线段就可以了\n\n> 声明几个必要的属性，将两个画笔基础的属性设置好\n\n```java\nimport com.example.tonjies.abase.app.App;\nimport com.example.tonjies.abase.util.ADensity;\n\n/**\n * Created by 舍长 on 2019/1/10\n * describe:\n */\npublic class EasyProgress extends View {\n\n     //灰色背景线段的画笔\n    private Paint bgPaint;\n\n    //实际进度绿色线段的画笔\n    private Paint progressPaint;\n\n    //进度条的最大宽度\n    private float maxProgress;\n\n    //进度条当前的宽度\n    private float currentProgress;\n\n    //当前View的宽度\n    private int width;\n\n    //当前View的高度\n    private int height;\n\n    //距离左边的内边距\n    private int paddingLeft;\n\n    //距离右边的内边距\n    private int paddingRight;\n\n\n    public EasyProgress(Context context) {\n        super(context);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initPaint();//初始化画笔\n    }\n\n    /**\n     * 初始化画笔\n     */\n    private void initPaint() {\n        //进度条背景画笔\n        bgPaint = new Paint();\n        bgPaint.setColor(Color.parseColor(\"#F0F0F0\"));//灰色\n        bgPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        bgPaint.setAntiAlias(true);//抗锯齿\n        bgPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        bgPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //设置进度画笔\n        progressPaint = new Paint();\n        progressPaint.setColor(Color.parseColor(\"#0DE6C2\"));//绿色\n        progressPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        progressPaint.setAntiAlias(true);//抗锯齿\n        progressPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        progressPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n        \n   \n    }\n}\n```\n\n> 其中ADensity的作用是将我们的dp单位转换为px单位，因为不同设备的px值又是不同的，所以必须要经过转换，工具类ADensity\n\n```java\n/**\n * Created by 舍长 on 2019/1/10\n * describe:\n */\npublic class ADensity {\n    /**\n     * 根据手机的分辨率从 dp 的单位 转成为 px(像素)\n     */\n    public static int dip2px(float dpValue) {\n        float scale = 1;\n        scale = App.getContext().getResources().getDisplayMetrics().density;\n        return (int) (dpValue * scale + 0.5f);\n    }\n\n    /**\n     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp\n     */\n    public static int px2dip(float pxValue) {\n        final float scale = App.getContext().getResources().getDisplayMetrics().density;\n        return (int) (pxValue / scale + 0.5f);\n    }\n\n\n    // 将px值转换为sp值\n    public static int px2sp(float pxValue) {\n        final float fontScale = App.getContext().getResources().getDisplayMetrics().scaledDensity;\n        return (int) (pxValue / fontScale + 0.5f);\n    }\n}\n\n```\n\n> App是我自定义的Application\n\n```java\n/**\n * Created by 舍长 on 2019/1/8\n * describe:\n */\npublic class App extends Application{\n    private static Context context;\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        context=this;\n    }\n\n    public static Context getContext() {\n        return context;\n    }\n}\n\n```\n\n> 记得去权限菜单引用\n\n```java\nandroid:name=\".app.App\"\n```\n\n> 在onLayout方法里面去初始化我们几个距离的参数，onLayout方法在View加载中只能加载一次，不过这几个参数都是不会改变的，因此在这里初始化没有问题滴\n\n```java\n  @Override\n  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n      super.onLayout(changed, left, top, right, bottom);\n      width = getWidth();//view的宽度\n      height = getHeight();//view的高度\n      paddLeft = getPaddingLeft();//距离左边的距离\n      paddRight = getPaddingRight();//距离右边的距离\n      //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n       maxProgress = width - getPaddingLeft() - getPaddingRight();\n   }\n```\n\n> 接着写我们的onDraw方法和onTouchEvent方法\n\n```java\n\n/**\n * Created by 舍长 on 2019/1/10\n * describe:一个简单的进度条\n */\npublic class EasyProgress extends View {\n\n    //灰色背景线段的画笔\n    private Paint bgPaint;\n\n    //实际进度绿色线段的画笔\n    private Paint progressPaint;\n\n    //灰色背景线段画笔的路径\n    private Path bgPath;\n\n    //实际进度绿色线段画笔的路径\n    private Path progressPath;\n\n    //进度条的最大宽度\n    private float maxProgress;\n\n    //进度条当前的宽度\n    private float currentProgress;\n\n    //当前View的宽度\n    private int width;\n\n    //当前View的高度\n    private int height;\n\n    //距离左边的内边距\n    private int paddingLeft;\n\n    //距离右边的内边距\n    private int paddingRight;\n\n\n    public EasyProgress(Context context) {\n        super(context);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initPaint();//初始化画笔\n    }\n\n    /**\n     * 初始化画笔\n     */\n    private void initPaint() {\n        //进度条背景画笔\n        bgPaint = new Paint();\n        bgPaint.setColor(Color.parseColor(\"#F0F0F0\"));//灰色\n        bgPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        bgPaint.setAntiAlias(true);//抗锯齿\n        bgPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        bgPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //设置进度画笔\n        progressPaint = new Paint();\n        progressPaint.setColor(Color.parseColor(\"#0DE6C2\"));//绿色\n        progressPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        progressPaint.setAntiAlias(true);//抗锯齿\n        progressPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        progressPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n    }\n\n\n    @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        width = getWidth();//view的宽度\n        height = getHeight();//view的高度\n        paddingLeft = getPaddingLeft();//距离左边的距离\n        paddingRight = getPaddingRight();//距离右边的距离\n        //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n        maxProgress = width - paddingLeft - paddingRight;\n    }\n\n    //绘制控件\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        L.d(\"maxProgress:\" + maxProgress);\n          //绘制背景线段\n        //从（左边距，View高度的一半）开始，到（View宽度-右边距，View高度的一半）之间绘制灰色背景线段\n        canvas.drawLine(paddingLeft, height / 2, width - paddingRight, \n                        height / 2, bgPaint);\n        //绘制实际进度线段\n        //从（左边距，View高度的一半）开始，到（现在的触摸到的进度宽度，View高度的一半）之间绘制绿色实际进度线段\n        canvas.drawLine(paddingLeft, height / 2, currentProgress, \n                        height / 2, progressPaint);\n    }\n\n    //触摸\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            //按住\n            case MotionEvent.ACTION_DOWN:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n            //移动\n            case MotionEvent.ACTION_MOVE:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n        }\n        return super.onTouchEvent(event);\n    }\n     //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        if (currentProgress < paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress > width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n        invalidate();\n    }\n}\n\n```\n\n> 因为我们要保证绿色线段的长度永远在实际线段长度（实际线段长度不等于View的长度，因为还要考虑View的内边距问题）之内，所以我么要在setProgress方法里面对获取到的触摸距离进行处理\n>\n> 这里写了一个触摸方法，就是触摸之后更新当前的进度值，并刷新UI，到这里我们可以去去xml声明使用一下了\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"\n    tools:context=\".module.easy.EasyActivity\">\n\n\n    <!--当前进度条的百分比进度值-->\n    <TextView\n        android:id=\"@+id/tvCurrentProgress\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"right|top\"\n        android:layout_marginRight=\"19dp\"\n        android:layout_marginTop=\"19dp\"\n        android:text=\"0/100\"\n        android:textColor=\"@color/colorPrimary\"\n        android:textSize=\"30sp\"\n        android:visibility=\"gone\" />\n\n\n    <com.example.tonjies.abase.view.EasyProgress\n        android:id=\"@+id/easyProgress\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"0dp\"\n        android:layout_weight=\"1\" />\n\n    <!--点击增加进度的按钮-->\n    <android.support.design.widget.FloatingActionButton\n        android:id=\"@+id/faButton\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"right|bottom\"\n        android:layout_marginBottom=\"29dp\"\n        android:layout_marginRight=\"29dp\"\n        android:elevation=\"8dp\"\n        android:src=\"@drawable/add\"\n        android:visibility=\"gone\"\n        app:backgroundTint=\"#0DE6C2\"\n        />\n\n</LinearLayout>\n```\n\n> 其中TextView会在后面显示进度条当前的进度值，而FloatingActionButton则是让我们点击后进度增加，该按钮需要添加design依赖，使用普通按钮代替也是可以的，两个组件暂时不需要，隐藏起来\n\n```\n//design组件\napi \'com.android.support:design:27.1.1\'\n```\n\n> 然后运行一下程序看看样子了\n\n![效果1.gif](https://upload-images.jianshu.io/upload_images/4002920-c51ef05c88bfef63.gif?imageMogr2/auto-orient/strip)\n\n\n> 但是我们现在的进度，都是屏幕上距离单位，这样的东西怎么上得了台面，所以我们接下来将距离转换为我们熟悉的百分比，并给进度条添加相应的圆点指示器\n>\n\n> 并且这里其实还是会有问题的，就是控件的高度。当我们将控件的高度设置为明确的数值或者Match时，看不出来，但是假如是设置成wrap_content，它就会把下面的所有控件的控件都“顶掉”\n\n> 因为这里还有没添加圆点指示器，所以我们暂时不对它进行处理，在后面添加了圆点指示器后，我们会通过重写onMeasure方法。来使得控件设置为wrap_content时，让控件的高度永远不会小于圆点指示器的高度\n\n\n\n#### 百分比，圆点指示器\n\n> 我们的线段距离单位有以下几个\n\n- maxProgress 线段的实际宽度\n- currentProgress 触摸到的点在View的宽度\n\n> 他们之间的关系可以用下面的公式来表示\n\n![进度条比例.png](https://upload-images.jianshu.io/upload_images/4002920-59b4c19f89fb58f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n> 其中MaxProgress对应我们的总量100，而我们的currentProgress的数字实际上是在View中的宽度，不是仅仅在maxProgress的宽度，所以还要减去左内边距，而右类边距同样会在方法中会处理，所以不必担心\n\n```java\n//如果当前进度大于宽度-右边距\nelse if (currentProgress > width - paddingRight) {\n    currentProgress = width - paddingRight;\n}\n```\n\n> 有了思路我们就可以直接上手了，我们声明相应的接口回调变量，用来向我们的Activity回调数据\n\n```java\n   //当前选中进度的回调\n    private OnProgressListener onProgressListener;\n\n    public interface OnProgressListener {\n        void onSelect(int progress);\n    }\n\n    public void setOnProgressListener(OnProgressListener onProgressListener) {\n        onProgressListener = onProgressListener;\n    }\n```\n\n> 修改setMotionProgress方法\n\n```java\n   @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            //按住\n            case MotionEvent.ACTION_DOWN:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n            //移动\n            case MotionEvent.ACTION_MOVE:\n                //获取当前触摸点，赋值给当前进度\n                setMotionProgress(event);\n                return true;\n        }\n        return super.onTouchEvent(event);\n    }\n\n     //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        setCurrentProgress();\n        //看数学公式就可以了,实际百分比进度数值\n        float result = ((currentProgress - paddingLeft) * 100) / maxProgress;\n        //进行空值判断\n        if(onProgressListener!=null){\n            onProgressListener.onSelect((int) result);\n        }\n        invalidate();\n    }\n\n```\n\n> 最后我们回到我们的Activity，写我们的回调方法\n\n```java\n\n/**\n * Created by 舍长\n * describe:最简单的进度条\n */\npublic class EasyActivity extends AppCompatActivity {\n\n    //进度条\n    @BindView(R.id.easyProgress)\n    EasyProgress easyProgress;\n\n    //当前进度条的百分比文本\n    @BindView(R.id.tvCurrentProgress)\n    TextView tvCurrentProgress;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_easy);\n        ButterKnife.bind(this);\n        tvCurrentProgress.setVisibility(View.VISIBLE);\n        easyProgress.setOnProgressListener(new EasyProgress.OnProgressListener() {\n            @Override\n            public void onSelect(int progress) {\n                tvCurrentProgress.setText(progress + \"/100\");\n                L.d(\"progress:\"+progress);\n            }\n        });\n    }\n\n}\n\n```\n\n> L是日志封装类，你使用普通Log也可以。效果图和上面其实没什么区别，就是多了个显示百分比进度\n\n\n\n- **添加圆点指示器**\n\n> 接着我们来给进度值添加一个圆点指示器，声明Paint变量，指示点的半径，初始化画笔属性\n\n```java\n//圆点指示器的画笔\nprivate Paint circlePaint;\n\n//圆点指示器的半径\nprivate int mCircleRadius = ADensity.dip2px(12);\n```\n\n> init方法里初始化属性\n\n```java\n//圆点指示器\ncirclePaint = new Paint();\ncirclePaint.setAntiAlias(true);//设置抗锯齿\ncirclePaint.setColor(Color.parseColor(\"#fafafa\"));//颜色\ncirclePaint.setShadowLayer(ADensity.dip2px(2), 0, 0, Color.parseColor(\"#38000000\"));//外阴影颜色\ncirclePaint.setStyle(Paint.Style.FILL);//填充\n```\n\n> 在onDraw方法里面使用\n\n```\n//要支持阴影下过必须关闭硬件加速\nsetLayerType(LAYER_TYPE_SOFTWARE, null);//发光效果不支持硬件加速\n//绘制圆点\ncanvas.drawCircle(currentProgress,getHeight()/2,mCircleRadius,circlePaint);\n```\n\n> 运行效果，转换的git图有点卡顿，实际效果并不会，这个放心\n\n![效果2.gif](https://upload-images.jianshu.io/upload_images/4002920-15c0cd81304bfb58.gif?imageMogr2/auto-orient/strip)\n\n\n\n\n> 到这里我们看似是完成了，但是假如我们在xml文件中不设置padd属性呢？\n\n![圆点指示器.png](https://upload-images.jianshu.io/upload_images/4002920-e5667258f0df3060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n> 圆点指示器有一半被顶出去了，因为当没有设置内边距的时候，我们进度条是以画布的起点开始算的，而我们的圆点指示器的圆中心点永远是当前进度的点\n\n> 所以我们还需要对线段的起始距离做一下处理，让它永远距离最左边和最右边有半个圆点指示器的距离。这里我们只要修改padd属性就好，这时候也体现出我们当时将几个常用的距离单位在onLayout中提取出来是一件多么明智的事情\n\n```java\n   //初始化几个距离参数\n    @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        width = getWidth();//view的宽度\n        height = getHeight();//view的高度\n\n        //让左边距至少为半个圆点指示器的距离\n        paddingLeft = getPaddingLeft();//距离左边的距离\n        if (getPaddingLeft() < mCircleRadius) {\n            L.d(\"onLayout\");\n            paddingLeft = mCircleRadius;\n        }\n        //让右边距至少为半个圆点指示器的距离\n        paddingRight = getPaddingRight();//距离右边的距离\n        if (getPaddingRight() < mCircleRadius) {\n            paddingRight = mCircleRadius;\n        }\n\n        //如果当前进度小于左边距\n        if (currentProgress < paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress > width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n        //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n        maxProgress = width - paddingLeft - paddingRight;\n    }\n```\n\n- 重写onMeasure方法\n\n> 上面说到的控件高度问题我们现在就可以解决了，我们制定一个最小高度标准，当用户设置的高度小于最小高度时，我们就强制让控件的高度等于我们的最小高度\n\n> 可能我们会下意识的觉得最小高度是圆点指示器的高度，但不要忽略了我们上面还给圆点指示器画笔添加了阴影\n\n```java\n//半径为2\ncirclePaint.setShadowLayer(ADensity.dip2px(2), 0, 0, Color.parseColor(\"#38000000\"));//外阴影颜色\n```\n\n> 所以最小高度应该为圆点指示器直径+ADensity.dip2px(4)\n\n```java\n    //重新计算控件的宽，高\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int width = MeasureSpec.getSize(widthMeasureSpec);\n        int height=measureHeight(heightMeasureSpec);\n        setMeasuredDimension(width, height);\n    }\n    \n//返回高度值\n    private int measureHeight(int heightMeasureSpec) {\n        int result;\n        int mode = MeasureSpec.getMode(heightMeasureSpec);//获取高度类型\n        int size = MeasureSpec.getSize(heightMeasureSpec);//获取高度数值\n        //制定的最小高度标准\n        int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n        //如果用户设定了指定大小\n        if (mode == MeasureSpec.EXACTLY) {\n            /**\n             * 虽然用户已经指定了大小，但是万一指定的大小小于圆点指示器的高度，\n             * 还是会出现显示不全的情况，所以还要进行判断\n             */\n            L.d(\"EXACTLY\");\n            if (size < minHeight) {\n                result = minHeight;\n            } else {\n                result = size;\n            }\n        }\n        //如果用户没有设定明确的值\n        else {\n            //设定高度为圆点指示器的直径\n            result = minHeight;\n        }\n        return result;\n    }\n```\n\n> 当控件的高度为明确的数值时我们判断是否大于大于规定的最小高度值，如果大于直接用。小于将高度设置为最小高度值。当不是明确的数值时我们就也它的高度值是最小高度值。\n>\n\n> OK，我们这样处理其实已经可以了，不过View其实已经很贴心的给我们准备好了一个resolveSize方法，该方法的作用和我们上面写的这段代码作用一模一样，这可不是我故意皮，毕竟熟悉流程还是好的嘛\n>\n> 所以最后我们的onMeasure方法里的代码为\n\n```java\n//重新计算控件的宽，高\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    int width = MeasureSpec.getSize(widthMeasureSpec);\n    int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n    int height = resolveSize(minHeight, heightMeasureSpec);\n    setMeasuredDimension(width, height);\n}\n```\n\n- 通过代码设置进度\n\n> 如如果你不希望让进度条是通过拖动增加进度的，而是自己设定数值，我们就提供一个方法，通过代码设置数值的方式来改变进度\n\n```java\n    //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        if (currentProgress < paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress > width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n        //看数学公式就可以了,实际百分比进度数值\n        float result = ((currentProgress - paddingLeft) * 100) / maxProgress;\n        //进行空值判断\n        if(onProgressListener!=null){\n            onProgressListener.onSelect((int) result);\n        }\n        invalidate();\n    }\n\n```\n\n> 到这里，我们发现在onLayout方法和这里都需要对currentProgress进行内边距的处理了，所以我们可以将这一段的代码抽取出来，这里我们只要用鼠标圈住这一段代码，使用快捷键Ctrl+Alt+M，AndroidStuio就会自动帮我们把所有相同的代码抽取成一个方法啦\n\n```java\n\n    private void setCurrentProgress() {\n        //如果当前进度小于左边距\n        if (currentProgress < paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress > width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n    }\n\n```\n\n> 完整代码\n\n```java\n/**\n * Created by 舍长 on 2019/1/10\n * describe:一个简单的进度条\n */\npublic class EasyProgress extends View {\n\n    //灰色背景线段的画笔\n    private Paint bgPaint;\n\n    //实际进度绿色线段的画笔\n    private Paint progressPaint;\n\n    //圆点指示器的画笔\n    private Paint circlePaint;\n\n    //圆点指示器的半径\n    private int mCircleRadius = ADensity.dip2px(12);\n\n    //进度条的最大宽度\n    private float maxProgress;\n\n    //进度条当前的宽度\n    private float currentProgress;\n\n    //当前View的宽度\n    private int width;\n\n    //当前View的高度\n    private int height;\n\n    //距离左边的内边距\n    private int paddingLeft;\n\n    //距离右边的内边距\n    private int paddingRight;\n\n\n    public EasyProgress(Context context) {\n        super(context);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initPaint();//初始化画笔\n    }\n\n    /**\n     * 初始化画笔\n     */\n    private void initPaint() {\n        //进度条背景画笔\n        bgPaint = new Paint();\n        bgPaint.setColor(Color.parseColor(\"#F0F0F0\"));//灰色\n        bgPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        bgPaint.setAntiAlias(true);//抗锯齿\n        bgPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        bgPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //设置进度画笔\n        progressPaint = new Paint();\n        progressPaint.setColor(Color.parseColor(\"#0DE6C2\"));//绿色\n        progressPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        progressPaint.setAntiAlias(true);//抗锯齿\n        progressPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头圆原的\n        progressPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //圆点指示器\n        circlePaint = new Paint();\n        circlePaint.setAntiAlias(true);//设置抗锯齿\n        circlePaint.setColor(Color.parseColor(\"#fafafa\"));//颜色\n        circlePaint.setShadowLayer(ADensity.dip2px(2), 0, 0, Color.parseColor(\"#38000000\"));//外阴影颜色\n        circlePaint.setStyle(Paint.Style.FILL);//填充\n    }\n\n    //重新计算控件的宽，高\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int width = MeasureSpec.getSize(widthMeasureSpec);\n        int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n        int height = resolveSize(minHeight, heightMeasureSpec);\n        setMeasuredDimension(width, height);\n    }\n\n    //返回高度值,作用和resolveSize方法一样\n    private int measureHeight(int heightMeasureSpec) {\n        int result;\n        int mode = MeasureSpec.getMode(heightMeasureSpec);//获取高度类型\n        int size = MeasureSpec.getSize(heightMeasureSpec);//获取高度数值\n        //制定的最小高度标准\n        int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n        //如果用户设定了指定大小\n        if (mode == MeasureSpec.EXACTLY) {\n            /**\n             * 虽然用户已经指定了大小，但是万一指定的大小小于圆点指示器的高度，\n             * 还是会出现显示不全的情况，所以还要进行判断\n             */\n            L.d(\"EXACTLY\");\n            if (size < minHeight) {\n                result = minHeight;\n            } else {\n                result = size;\n            }\n        }\n        //如果用户没有设定明确的值\n        else {\n            //设定高度为圆点指示器的直径\n            result = minHeight;\n        }\n        return result;\n    }\n\n    //初始化几个距离参数\n    @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        width = getWidth();//view的宽度\n        height = getHeight();//view的高度\n\n        //让左边距至少为半个圆点指示器的距离\n        paddingLeft = getPaddingLeft();//距离左边的距离\n        if (getPaddingLeft() < mCircleRadius) {\n            L.d(\"onLayout\");\n            paddingLeft = mCircleRadius;\n        }\n        //让右边距至少为半个圆点指示器的距离\n        paddingRight = getPaddingRight();//距离右边的距离\n        if (getPaddingRight() < mCircleRadius) {\n            paddingRight = mCircleRadius;\n        }\n\n        //如果当前进度小于左边距\n        setCurrentProgress();\n        //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n        maxProgress = width - paddingLeft - paddingRight;\n    }\n\n    //绘制控件\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n//        L.d(\"onDraw\");\n        //绘制背景线段\n        L.d(\"paddLeft:\" + paddingLeft + \" paddRight:\" + paddingRight);\n        //从（左边距，View高度的一半）开始，到（View宽度-右边距，View高度的一半）还将绘制灰色背景线段\n        canvas.drawLine(paddingLeft, height / 2, width - paddingRight, height / 2, bgPaint);\n        //绘制实际进度线段\n        //从（左边距，View高度的一半）开始，到（现在的触摸到的进度宽度，View高度的一半）还将绘制灰色背景线段\n        canvas.drawLine(paddingLeft, height / 2, currentProgress, height / 2, progressPaint);\n        //要支持阴影下过必须关闭硬件加速\n        setLayerType(LAYER_TYPE_SOFTWARE, null);//发光效果不支持硬件加速\n        //绘制圆点\n        canvas.drawCircle(currentProgress, getHeight() / 2, mCircleRadius, circlePaint);\n    }\n\n    //触摸\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            //按住\n            case MotionEvent.ACTION_DOWN:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n            //移动\n            case MotionEvent.ACTION_MOVE:\n                //获取当前触摸点，赋值给当前进度\n                setMotionProgress(event);\n                return true;\n        }\n        return super.onTouchEvent(event);\n    }\n\n    //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        setCurrentProgress();\n        //看数学公式就可以了,实际百分比进度数值\n        float result = ((currentProgress - paddingLeft) * 100) / maxProgress;\n        //进行空值判断\n        if(onProgressListener!=null){\n            onProgressListener.onSelect((int) result);\n        }\n        invalidate();\n    }\n\n\n    //设置当前进度条进度,从1到100\n    public void setProgress(int progress) {\n        if (progress > 100 || progress < 0) {\n            Toast.makeText(App.getContext(), \"输入的进度值不符合规范\", Toast.LENGTH_SHORT).show();\n        }\n        setCurrentProgress();\n        //设置当前进度的宽度\n        currentProgress = ((progress * maxProgress) / 100) + paddingLeft;\n        onProgressListener.onSelect(progress);\n        invalidate();\n    }\n\n    private void setCurrentProgress() {\n        if (currentProgress < paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress > width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n    }\n\n    //当前选中进度的回调\n    private OnProgressListener onProgressListener;\n\n    public interface OnProgressListener {\n        void onSelect(int progress);\n    }\n\n    public void setOnProgressListener(OnProgressListener onProgressListener) {\n        this.onProgressListener = onProgressListener;\n    }\n}\n\n\n```\n\n> 在Actiivty中去使用\n\n```java\n/**\n * Created by 舍长\n * describe:最简单的进度条\n */\npublic class EasyActivity extends AppCompatActivity {\n\n    //进度条\n    @BindView(R.id.easyProgress)\n    EasyProgress easyProgress;\n\n    //当前进度条的百分比文本\n    @BindView(R.id.tvCurrentProgress)\n    TextView tvCurrentProgress;\n\n    //增加进度按钮\n    @BindView(R.id.faButton)\n    FloatingActionButton faButton;\n\n    //每次累加的进度\n    private int progress = 0;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_easy);\n        ButterKnife.bind(this);\n        tvCurrentProgress.setVisibility(View.VISIBLE);\n        faButton.setVisibility(View.VISIBLE);\n        //监听数值的变化\n        easyProgress.setOnProgressListener(new EasyProgress.OnProgressListener() {\n            @Override\n            public void onSelect(int progress) {\n                tvCurrentProgress.setText(progress + \"/100\");\n//                L.d(\"progress:\"+progress);\n            }\n        });\n        //设置进度值\n        faButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (progress < 100) {\n                    progress += 10;\n                    easyProgress.setProgress(progress);\n                } else {\n                    progress = 0;\n                }\n            }\n        });\n    }\n\n}\n\n```\n\n到这里你可能会说，就这么一点效果，弄得这么麻烦，我继承个SeekBar，重写几个属性不是美滋滋？确实，就当前的效果来说继承个Seekbar就可以了，但是现在你的UI表示，我想要你在进度条下面给我来个同步移动的文字！如下\n\n![进度条下方的文字.png](https://upload-images.jianshu.io/upload_images/4002920-3c16c66b9aebfd16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n> 加入你是使用的Seekbar，那么你已经凉了，没法判断圆点坐标的位置啊！（或者是我不知道？！），而这个效果也是我下一篇想要写的效果\n\n\n\n\n',1630080000,'<blockquote>\n<p>实际效果，我们可以通过拖拽来设置进度，也可以通过点击按钮来设置进度</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-87b9f10a596cf37a.gif?imageMogr2/auto-orient/strip\" alt=\"最终效果.gif\"></p>\n<blockquote>\n<p>视频转Git会有卡顿感，实际运行并不会，项目源代码已经上传到<a href=\"https://github.com/13531982270/BlogDemo4\">仓库</a>的AProgress文件夹，</p>\n<p>要看懂本篇文章，需要你掌握Paint类，Canvas类的基本使用，可以查看以下文章学习</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/d86ea15dfdd2\">随风飘扬的微笑</a></li>\n</ul>\n<blockquote>\n<p>该教程分为两个部分</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/a0b6f171b872\">自定义可拖拽评价进度条一</a></li>\n<li><a href=\"https://www.jianshu.com/p/975fe34c7c27\">自定义可拖拽评价进度条二</a></li>\n</ul>\n<a id=\"toc41\" href=\"#toc41\" class=\"anchor-fix\"><h4>触摸改变进度条的进度</h4></a>\n<blockquote>\n<p>我们创建EasyProgress，继承于View，纯手工的来绘制Progress。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-13d7178a88c43420.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"灰色.png\"></p>\n<blockquote>\n<p>声明两个Paint变量，我们需要一个画笔来绘制一条总长度的线段，颜色为灰色。另外一个画笔来绘制实际选中长度的线段，颜色为绿色。</p>\n<p>当我们的进度改变时，只需要将实际进度（绿色）的线段长度扩大，去覆盖灰色（背景）的线段就可以了</p>\n</blockquote>\n<blockquote>\n<p>声明几个必要的属性，将两个画笔基础的属性设置好</p>\n</blockquote>\n<pre><code class=\"language-java\">import com.example.tonjies.abase.app.App;\nimport com.example.tonjies.abase.util.ADensity;\n\n/**\n * Created by 舍长 on 2019/1/10\n * describe:\n */\npublic class EasyProgress extends View {\n\n     //灰色背景线段的画笔\n    private Paint bgPaint;\n\n    //实际进度绿色线段的画笔\n    private Paint progressPaint;\n\n    //进度条的最大宽度\n    private float maxProgress;\n\n    //进度条当前的宽度\n    private float currentProgress;\n\n    //当前View的宽度\n    private int width;\n\n    //当前View的高度\n    private int height;\n\n    //距离左边的内边距\n    private int paddingLeft;\n\n    //距离右边的内边距\n    private int paddingRight;\n\n\n    public EasyProgress(Context context) {\n        super(context);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initPaint();//初始化画笔\n    }\n\n    /**\n     * 初始化画笔\n     */\n    private void initPaint() {\n        //进度条背景画笔\n        bgPaint = new Paint();\n        bgPaint.setColor(Color.parseColor(&quot;#F0F0F0&quot;));//灰色\n        bgPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        bgPaint.setAntiAlias(true);//抗锯齿\n        bgPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        bgPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //设置进度画笔\n        progressPaint = new Paint();\n        progressPaint.setColor(Color.parseColor(&quot;#0DE6C2&quot;));//绿色\n        progressPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        progressPaint.setAntiAlias(true);//抗锯齿\n        progressPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        progressPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n\n    }\n}</code></pre>\n<blockquote>\n<p>其中ADensity的作用是将我们的dp单位转换为px单位，因为不同设备的px值又是不同的，所以必须要经过转换，工具类ADensity</p>\n</blockquote>\n<pre><code class=\"language-java\">/**\n * Created by 舍长 on 2019/1/10\n * describe:\n */\npublic class ADensity {\n    /**\n     * 根据手机的分辨率从 dp 的单位 转成为 px(像素)\n     */\n    public static int dip2px(float dpValue) {\n        float scale = 1;\n        scale = App.getContext().getResources().getDisplayMetrics().density;\n        return (int) (dpValue * scale + 0.5f);\n    }\n\n    /**\n     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp\n     */\n    public static int px2dip(float pxValue) {\n        final float scale = App.getContext().getResources().getDisplayMetrics().density;\n        return (int) (pxValue / scale + 0.5f);\n    }\n\n\n    // 将px值转换为sp值\n    public static int px2sp(float pxValue) {\n        final float fontScale = App.getContext().getResources().getDisplayMetrics().scaledDensity;\n        return (int) (pxValue / fontScale + 0.5f);\n    }\n}\n</code></pre>\n<blockquote>\n<p>App是我自定义的Application</p>\n</blockquote>\n<pre><code class=\"language-java\">/**\n * Created by 舍长 on 2019/1/8\n * describe:\n */\npublic class App extends Application{\n    private static Context context;\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        context=this;\n    }\n\n    public static Context getContext() {\n        return context;\n    }\n}\n</code></pre>\n<blockquote>\n<p>记得去权限菜单引用</p>\n</blockquote>\n<pre><code class=\"language-java\">android:name=&quot;.app.App&quot;</code></pre>\n<blockquote>\n<p>在onLayout方法里面去初始化我们几个距离的参数，onLayout方法在View加载中只能加载一次，不过这几个参数都是不会改变的，因此在这里初始化没有问题滴</p>\n</blockquote>\n<pre><code class=\"language-java\">  @Override\n  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n      super.onLayout(changed, left, top, right, bottom);\n      width = getWidth();//view的宽度\n      height = getHeight();//view的高度\n      paddLeft = getPaddingLeft();//距离左边的距离\n      paddRight = getPaddingRight();//距离右边的距离\n      //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n       maxProgress = width - getPaddingLeft() - getPaddingRight();\n   }</code></pre>\n<blockquote>\n<p>接着写我们的onDraw方法和onTouchEvent方法</p>\n</blockquote>\n<pre><code class=\"language-java\">\n/**\n * Created by 舍长 on 2019/1/10\n * describe:一个简单的进度条\n */\npublic class EasyProgress extends View {\n\n    //灰色背景线段的画笔\n    private Paint bgPaint;\n\n    //实际进度绿色线段的画笔\n    private Paint progressPaint;\n\n    //灰色背景线段画笔的路径\n    private Path bgPath;\n\n    //实际进度绿色线段画笔的路径\n    private Path progressPath;\n\n    //进度条的最大宽度\n    private float maxProgress;\n\n    //进度条当前的宽度\n    private float currentProgress;\n\n    //当前View的宽度\n    private int width;\n\n    //当前View的高度\n    private int height;\n\n    //距离左边的内边距\n    private int paddingLeft;\n\n    //距离右边的内边距\n    private int paddingRight;\n\n\n    public EasyProgress(Context context) {\n        super(context);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initPaint();//初始化画笔\n    }\n\n    /**\n     * 初始化画笔\n     */\n    private void initPaint() {\n        //进度条背景画笔\n        bgPaint = new Paint();\n        bgPaint.setColor(Color.parseColor(&quot;#F0F0F0&quot;));//灰色\n        bgPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        bgPaint.setAntiAlias(true);//抗锯齿\n        bgPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        bgPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //设置进度画笔\n        progressPaint = new Paint();\n        progressPaint.setColor(Color.parseColor(&quot;#0DE6C2&quot;));//绿色\n        progressPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        progressPaint.setAntiAlias(true);//抗锯齿\n        progressPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        progressPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n    }\n\n\n    @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        width = getWidth();//view的宽度\n        height = getHeight();//view的高度\n        paddingLeft = getPaddingLeft();//距离左边的距离\n        paddingRight = getPaddingRight();//距离右边的距离\n        //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n        maxProgress = width - paddingLeft - paddingRight;\n    }\n\n    //绘制控件\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        L.d(&quot;maxProgress:&quot; + maxProgress);\n          //绘制背景线段\n        //从（左边距，View高度的一半）开始，到（View宽度-右边距，View高度的一半）之间绘制灰色背景线段\n        canvas.drawLine(paddingLeft, height / 2, width - paddingRight, \n                        height / 2, bgPaint);\n        //绘制实际进度线段\n        //从（左边距，View高度的一半）开始，到（现在的触摸到的进度宽度，View高度的一半）之间绘制绿色实际进度线段\n        canvas.drawLine(paddingLeft, height / 2, currentProgress, \n                        height / 2, progressPaint);\n    }\n\n    //触摸\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            //按住\n            case MotionEvent.ACTION_DOWN:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n            //移动\n            case MotionEvent.ACTION_MOVE:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n        }\n        return super.onTouchEvent(event);\n    }\n     //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        if (currentProgress &lt; paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress &gt; width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n        invalidate();\n    }\n}\n</code></pre>\n<blockquote>\n<p>因为我们要保证绿色线段的长度永远在实际线段长度（实际线段长度不等于View的长度，因为还要考虑View的内边距问题）之内，所以我么要在setProgress方法里面对获取到的触摸距离进行处理</p>\n<p>这里写了一个触摸方法，就是触摸之后更新当前的进度值，并刷新UI，到这里我们可以去去xml声明使用一下了</p>\n</blockquote>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:orientation=&quot;vertical&quot;\n    tools:context=&quot;.module.easy.EasyActivity&quot;&gt;\n\n\n    &lt;!--当前进度条的百分比进度值--&gt;\n    &lt;TextView\n        android:id=&quot;@+id/tvCurrentProgress&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_gravity=&quot;right|top&quot;\n        android:layout_marginRight=&quot;19dp&quot;\n        android:layout_marginTop=&quot;19dp&quot;\n        android:text=&quot;0/100&quot;\n        android:textColor=&quot;@color/colorPrimary&quot;\n        android:textSize=&quot;30sp&quot;\n        android:visibility=&quot;gone&quot; /&gt;\n\n\n    &lt;com.example.tonjies.abase.view.EasyProgress\n        android:id=&quot;@+id/easyProgress&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;0dp&quot;\n        android:layout_weight=&quot;1&quot; /&gt;\n\n    &lt;!--点击增加进度的按钮--&gt;\n    &lt;android.support.design.widget.FloatingActionButton\n        android:id=&quot;@+id/faButton&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:layout_gravity=&quot;right|bottom&quot;\n        android:layout_marginBottom=&quot;29dp&quot;\n        android:layout_marginRight=&quot;29dp&quot;\n        android:elevation=&quot;8dp&quot;\n        android:src=&quot;@drawable/add&quot;\n        android:visibility=&quot;gone&quot;\n        app:backgroundTint=&quot;#0DE6C2&quot;\n        /&gt;\n\n&lt;/LinearLayout&gt;</code></pre><blockquote>\n<p>其中TextView会在后面显示进度条当前的进度值，而FloatingActionButton则是让我们点击后进度增加，该按钮需要添加design依赖，使用普通按钮代替也是可以的，两个组件暂时不需要，隐藏起来</p>\n</blockquote>\n<pre><code>//design组件\napi &#39;com.android.support:design:27.1.1&#39;</code></pre><blockquote>\n<p>然后运行一下程序看看样子了</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-c51ef05c88bfef63.gif?imageMogr2/auto-orient/strip\" alt=\"效果1.gif\"></p>\n<blockquote>\n<p>但是我们现在的进度，都是屏幕上距离单位，这样的东西怎么上得了台面，所以我们接下来将距离转换为我们熟悉的百分比，并给进度条添加相应的圆点指示器</p>\n</blockquote>\n<blockquote>\n<p>并且这里其实还是会有问题的，就是控件的高度。当我们将控件的高度设置为明确的数值或者Match时，看不出来，但是假如是设置成wrap_content，它就会把下面的所有控件的控件都“顶掉”</p>\n</blockquote>\n<blockquote>\n<p>因为这里还有没添加圆点指示器，所以我们暂时不对它进行处理，在后面添加了圆点指示器后，我们会通过重写onMeasure方法。来使得控件设置为wrap_content时，让控件的高度永远不会小于圆点指示器的高度</p>\n</blockquote>\n<a id=\"toc42\" href=\"#toc42\" class=\"anchor-fix\"><h4>百分比，圆点指示器</h4></a>\n<blockquote>\n<p>我们的线段距离单位有以下几个</p>\n</blockquote>\n<ul>\n<li>maxProgress 线段的实际宽度</li>\n<li>currentProgress 触摸到的点在View的宽度</li>\n</ul>\n<blockquote>\n<p>他们之间的关系可以用下面的公式来表示</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-59b4c19f89fb58f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"进度条比例.png\"></p>\n<blockquote>\n<p>其中MaxProgress对应我们的总量100，而我们的currentProgress的数字实际上是在View中的宽度，不是仅仅在maxProgress的宽度，所以还要减去左内边距，而右类边距同样会在方法中会处理，所以不必担心</p>\n</blockquote>\n<pre><code class=\"language-java\">//如果当前进度大于宽度-右边距\nelse if (currentProgress &gt; width - paddingRight) {\n    currentProgress = width - paddingRight;\n}</code></pre>\n<blockquote>\n<p>有了思路我们就可以直接上手了，我们声明相应的接口回调变量，用来向我们的Activity回调数据</p>\n</blockquote>\n<pre><code class=\"language-java\">   //当前选中进度的回调\n    private OnProgressListener onProgressListener;\n\n    public interface OnProgressListener {\n        void onSelect(int progress);\n    }\n\n    public void setOnProgressListener(OnProgressListener onProgressListener) {\n        onProgressListener = onProgressListener;\n    }</code></pre>\n<blockquote>\n<p>修改setMotionProgress方法</p>\n</blockquote>\n<pre><code class=\"language-java\">   @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            //按住\n            case MotionEvent.ACTION_DOWN:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n            //移动\n            case MotionEvent.ACTION_MOVE:\n                //获取当前触摸点，赋值给当前进度\n                setMotionProgress(event);\n                return true;\n        }\n        return super.onTouchEvent(event);\n    }\n\n     //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        setCurrentProgress();\n        //看数学公式就可以了,实际百分比进度数值\n        float result = ((currentProgress - paddingLeft) * 100) / maxProgress;\n        //进行空值判断\n        if(onProgressListener!=null){\n            onProgressListener.onSelect((int) result);\n        }\n        invalidate();\n    }\n</code></pre>\n<blockquote>\n<p>最后我们回到我们的Activity，写我们的回调方法</p>\n</blockquote>\n<pre><code class=\"language-java\">\n/**\n * Created by 舍长\n * describe:最简单的进度条\n */\npublic class EasyActivity extends AppCompatActivity {\n\n    //进度条\n    @BindView(R.id.easyProgress)\n    EasyProgress easyProgress;\n\n    //当前进度条的百分比文本\n    @BindView(R.id.tvCurrentProgress)\n    TextView tvCurrentProgress;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_easy);\n        ButterKnife.bind(this);\n        tvCurrentProgress.setVisibility(View.VISIBLE);\n        easyProgress.setOnProgressListener(new EasyProgress.OnProgressListener() {\n            @Override\n            public void onSelect(int progress) {\n                tvCurrentProgress.setText(progress + &quot;/100&quot;);\n                L.d(&quot;progress:&quot;+progress);\n            }\n        });\n    }\n\n}\n</code></pre>\n<blockquote>\n<p>L是日志封装类，你使用普通Log也可以。效果图和上面其实没什么区别，就是多了个显示百分比进度</p>\n</blockquote>\n<ul>\n<li><strong>添加圆点指示器</strong></li>\n</ul>\n<blockquote>\n<p>接着我们来给进度值添加一个圆点指示器，声明Paint变量，指示点的半径，初始化画笔属性</p>\n</blockquote>\n<pre><code class=\"language-java\">//圆点指示器的画笔\nprivate Paint circlePaint;\n\n//圆点指示器的半径\nprivate int mCircleRadius = ADensity.dip2px(12);</code></pre>\n<blockquote>\n<p>init方法里初始化属性</p>\n</blockquote>\n<pre><code class=\"language-java\">//圆点指示器\ncirclePaint = new Paint();\ncirclePaint.setAntiAlias(true);//设置抗锯齿\ncirclePaint.setColor(Color.parseColor(&quot;#fafafa&quot;));//颜色\ncirclePaint.setShadowLayer(ADensity.dip2px(2), 0, 0, Color.parseColor(&quot;#38000000&quot;));//外阴影颜色\ncirclePaint.setStyle(Paint.Style.FILL);//填充</code></pre>\n<blockquote>\n<p>在onDraw方法里面使用</p>\n</blockquote>\n<pre><code>//要支持阴影下过必须关闭硬件加速\nsetLayerType(LAYER_TYPE_SOFTWARE, null);//发光效果不支持硬件加速\n//绘制圆点\ncanvas.drawCircle(currentProgress,getHeight()/2,mCircleRadius,circlePaint);</code></pre><blockquote>\n<p>运行效果，转换的git图有点卡顿，实际效果并不会，这个放心</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-15c0cd81304bfb58.gif?imageMogr2/auto-orient/strip\" alt=\"效果2.gif\"></p>\n<blockquote>\n<p>到这里我们看似是完成了，但是假如我们在xml文件中不设置padd属性呢？</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-e5667258f0df3060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"圆点指示器.png\"></p>\n<blockquote>\n<p>圆点指示器有一半被顶出去了，因为当没有设置内边距的时候，我们进度条是以画布的起点开始算的，而我们的圆点指示器的圆中心点永远是当前进度的点</p>\n</blockquote>\n<blockquote>\n<p>所以我们还需要对线段的起始距离做一下处理，让它永远距离最左边和最右边有半个圆点指示器的距离。这里我们只要修改padd属性就好，这时候也体现出我们当时将几个常用的距离单位在onLayout中提取出来是一件多么明智的事情</p>\n</blockquote>\n<pre><code class=\"language-java\">   //初始化几个距离参数\n    @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        width = getWidth();//view的宽度\n        height = getHeight();//view的高度\n\n        //让左边距至少为半个圆点指示器的距离\n        paddingLeft = getPaddingLeft();//距离左边的距离\n        if (getPaddingLeft() &lt; mCircleRadius) {\n            L.d(&quot;onLayout&quot;);\n            paddingLeft = mCircleRadius;\n        }\n        //让右边距至少为半个圆点指示器的距离\n        paddingRight = getPaddingRight();//距离右边的距离\n        if (getPaddingRight() &lt; mCircleRadius) {\n            paddingRight = mCircleRadius;\n        }\n\n        //如果当前进度小于左边距\n        if (currentProgress &lt; paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress &gt; width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n        //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n        maxProgress = width - paddingLeft - paddingRight;\n    }</code></pre>\n<ul>\n<li>重写onMeasure方法</li>\n</ul>\n<blockquote>\n<p>上面说到的控件高度问题我们现在就可以解决了，我们制定一个最小高度标准，当用户设置的高度小于最小高度时，我们就强制让控件的高度等于我们的最小高度</p>\n</blockquote>\n<blockquote>\n<p>可能我们会下意识的觉得最小高度是圆点指示器的高度，但不要忽略了我们上面还给圆点指示器画笔添加了阴影</p>\n</blockquote>\n<pre><code class=\"language-java\">//半径为2\ncirclePaint.setShadowLayer(ADensity.dip2px(2), 0, 0, Color.parseColor(&quot;#38000000&quot;));//外阴影颜色</code></pre>\n<blockquote>\n<p>所以最小高度应该为圆点指示器直径+ADensity.dip2px(4)</p>\n</blockquote>\n<pre><code class=\"language-java\">    //重新计算控件的宽，高\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int width = MeasureSpec.getSize(widthMeasureSpec);\n        int height=measureHeight(heightMeasureSpec);\n        setMeasuredDimension(width, height);\n    }\n\n//返回高度值\n    private int measureHeight(int heightMeasureSpec) {\n        int result;\n        int mode = MeasureSpec.getMode(heightMeasureSpec);//获取高度类型\n        int size = MeasureSpec.getSize(heightMeasureSpec);//获取高度数值\n        //制定的最小高度标准\n        int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n        //如果用户设定了指定大小\n        if (mode == MeasureSpec.EXACTLY) {\n            /**\n             * 虽然用户已经指定了大小，但是万一指定的大小小于圆点指示器的高度，\n             * 还是会出现显示不全的情况，所以还要进行判断\n             */\n            L.d(&quot;EXACTLY&quot;);\n            if (size &lt; minHeight) {\n                result = minHeight;\n            } else {\n                result = size;\n            }\n        }\n        //如果用户没有设定明确的值\n        else {\n            //设定高度为圆点指示器的直径\n            result = minHeight;\n        }\n        return result;\n    }</code></pre>\n<blockquote>\n<p>当控件的高度为明确的数值时我们判断是否大于大于规定的最小高度值，如果大于直接用。小于将高度设置为最小高度值。当不是明确的数值时我们就也它的高度值是最小高度值。</p>\n</blockquote>\n<blockquote>\n<p>OK，我们这样处理其实已经可以了，不过View其实已经很贴心的给我们准备好了一个resolveSize方法，该方法的作用和我们上面写的这段代码作用一模一样，这可不是我故意皮，毕竟熟悉流程还是好的嘛</p>\n<p>所以最后我们的onMeasure方法里的代码为</p>\n</blockquote>\n<pre><code class=\"language-java\">//重新计算控件的宽，高\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    int width = MeasureSpec.getSize(widthMeasureSpec);\n    int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n    int height = resolveSize(minHeight, heightMeasureSpec);\n    setMeasuredDimension(width, height);\n}</code></pre>\n<ul>\n<li>通过代码设置进度</li>\n</ul>\n<blockquote>\n<p>如如果你不希望让进度条是通过拖动增加进度的，而是自己设定数值，我们就提供一个方法，通过代码设置数值的方式来改变进度</p>\n</blockquote>\n<pre><code class=\"language-java\">    //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        if (currentProgress &lt; paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress &gt; width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n        //看数学公式就可以了,实际百分比进度数值\n        float result = ((currentProgress - paddingLeft) * 100) / maxProgress;\n        //进行空值判断\n        if(onProgressListener!=null){\n            onProgressListener.onSelect((int) result);\n        }\n        invalidate();\n    }\n</code></pre>\n<blockquote>\n<p>到这里，我们发现在onLayout方法和这里都需要对currentProgress进行内边距的处理了，所以我们可以将这一段的代码抽取出来，这里我们只要用鼠标圈住这一段代码，使用快捷键Ctrl+Alt+M，AndroidStuio就会自动帮我们把所有相同的代码抽取成一个方法啦</p>\n</blockquote>\n<pre><code class=\"language-java\">\n    private void setCurrentProgress() {\n        //如果当前进度小于左边距\n        if (currentProgress &lt; paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress &gt; width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n    }\n</code></pre>\n<blockquote>\n<p>完整代码</p>\n</blockquote>\n<pre><code class=\"language-java\">/**\n * Created by 舍长 on 2019/1/10\n * describe:一个简单的进度条\n */\npublic class EasyProgress extends View {\n\n    //灰色背景线段的画笔\n    private Paint bgPaint;\n\n    //实际进度绿色线段的画笔\n    private Paint progressPaint;\n\n    //圆点指示器的画笔\n    private Paint circlePaint;\n\n    //圆点指示器的半径\n    private int mCircleRadius = ADensity.dip2px(12);\n\n    //进度条的最大宽度\n    private float maxProgress;\n\n    //进度条当前的宽度\n    private float currentProgress;\n\n    //当前View的宽度\n    private int width;\n\n    //当前View的高度\n    private int height;\n\n    //距离左边的内边距\n    private int paddingLeft;\n\n    //距离右边的内边距\n    private int paddingRight;\n\n\n    public EasyProgress(Context context) {\n        super(context);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public EasyProgress(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initPaint();//初始化画笔\n    }\n\n    /**\n     * 初始化画笔\n     */\n    private void initPaint() {\n        //进度条背景画笔\n        bgPaint = new Paint();\n        bgPaint.setColor(Color.parseColor(&quot;#F0F0F0&quot;));//灰色\n        bgPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        bgPaint.setAntiAlias(true);//抗锯齿\n        bgPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头是圆的\n        bgPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //设置进度画笔\n        progressPaint = new Paint();\n        progressPaint.setColor(Color.parseColor(&quot;#0DE6C2&quot;));//绿色\n        progressPaint.setStyle(Paint.Style.FILL_AND_STROKE);//填充且描边\n        progressPaint.setAntiAlias(true);//抗锯齿\n        progressPaint.setStrokeCap(Paint.Cap.ROUND);//线冒的头圆原的\n        progressPaint.setStrokeWidth(ADensity.dip2px(3));//大小为3dp转px\n\n        //圆点指示器\n        circlePaint = new Paint();\n        circlePaint.setAntiAlias(true);//设置抗锯齿\n        circlePaint.setColor(Color.parseColor(&quot;#fafafa&quot;));//颜色\n        circlePaint.setShadowLayer(ADensity.dip2px(2), 0, 0, Color.parseColor(&quot;#38000000&quot;));//外阴影颜色\n        circlePaint.setStyle(Paint.Style.FILL);//填充\n    }\n\n    //重新计算控件的宽，高\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int width = MeasureSpec.getSize(widthMeasureSpec);\n        int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n        int height = resolveSize(minHeight, heightMeasureSpec);\n        setMeasuredDimension(width, height);\n    }\n\n    //返回高度值,作用和resolveSize方法一样\n    private int measureHeight(int heightMeasureSpec) {\n        int result;\n        int mode = MeasureSpec.getMode(heightMeasureSpec);//获取高度类型\n        int size = MeasureSpec.getSize(heightMeasureSpec);//获取高度数值\n        //制定的最小高度标准\n        int minHeight = mCircleRadius * 2 + (ADensity.dip2px(2) * 2);\n        //如果用户设定了指定大小\n        if (mode == MeasureSpec.EXACTLY) {\n            /**\n             * 虽然用户已经指定了大小，但是万一指定的大小小于圆点指示器的高度，\n             * 还是会出现显示不全的情况，所以还要进行判断\n             */\n            L.d(&quot;EXACTLY&quot;);\n            if (size &lt; minHeight) {\n                result = minHeight;\n            } else {\n                result = size;\n            }\n        }\n        //如果用户没有设定明确的值\n        else {\n            //设定高度为圆点指示器的直径\n            result = minHeight;\n        }\n        return result;\n    }\n\n    //初始化几个距离参数\n    @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        width = getWidth();//view的宽度\n        height = getHeight();//view的高度\n\n        //让左边距至少为半个圆点指示器的距离\n        paddingLeft = getPaddingLeft();//距离左边的距离\n        if (getPaddingLeft() &lt; mCircleRadius) {\n            L.d(&quot;onLayout&quot;);\n            paddingLeft = mCircleRadius;\n        }\n        //让右边距至少为半个圆点指示器的距离\n        paddingRight = getPaddingRight();//距离右边的距离\n        if (getPaddingRight() &lt; mCircleRadius) {\n            paddingRight = mCircleRadius;\n        }\n\n        //如果当前进度小于左边距\n        setCurrentProgress();\n        //最大进度长度等于View的宽度-(左边的内边距+右边的内边距)\n        maxProgress = width - paddingLeft - paddingRight;\n    }\n\n    //绘制控件\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n//        L.d(&quot;onDraw&quot;);\n        //绘制背景线段\n        L.d(&quot;paddLeft:&quot; + paddingLeft + &quot; paddRight:&quot; + paddingRight);\n        //从（左边距，View高度的一半）开始，到（View宽度-右边距，View高度的一半）还将绘制灰色背景线段\n        canvas.drawLine(paddingLeft, height / 2, width - paddingRight, height / 2, bgPaint);\n        //绘制实际进度线段\n        //从（左边距，View高度的一半）开始，到（现在的触摸到的进度宽度，View高度的一半）还将绘制灰色背景线段\n        canvas.drawLine(paddingLeft, height / 2, currentProgress, height / 2, progressPaint);\n        //要支持阴影下过必须关闭硬件加速\n        setLayerType(LAYER_TYPE_SOFTWARE, null);//发光效果不支持硬件加速\n        //绘制圆点\n        canvas.drawCircle(currentProgress, getHeight() / 2, mCircleRadius, circlePaint);\n    }\n\n    //触摸\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            //按住\n            case MotionEvent.ACTION_DOWN:\n                //设置进度值\n                setMotionProgress(event);\n                return true;\n            //移动\n            case MotionEvent.ACTION_MOVE:\n                //获取当前触摸点，赋值给当前进度\n                setMotionProgress(event);\n                return true;\n        }\n        return super.onTouchEvent(event);\n    }\n\n    //设置进度值\n    private void setMotionProgress(MotionEvent event) {\n        //获取当前触摸点，赋值给当前进度\n        currentProgress = (int) event.getX();\n        //如果当前进度小于左边距\n        setCurrentProgress();\n        //看数学公式就可以了,实际百分比进度数值\n        float result = ((currentProgress - paddingLeft) * 100) / maxProgress;\n        //进行空值判断\n        if(onProgressListener!=null){\n            onProgressListener.onSelect((int) result);\n        }\n        invalidate();\n    }\n\n\n    //设置当前进度条进度,从1到100\n    public void setProgress(int progress) {\n        if (progress &gt; 100 || progress &lt; 0) {\n            Toast.makeText(App.getContext(), &quot;输入的进度值不符合规范&quot;, Toast.LENGTH_SHORT).show();\n        }\n        setCurrentProgress();\n        //设置当前进度的宽度\n        currentProgress = ((progress * maxProgress) / 100) + paddingLeft;\n        onProgressListener.onSelect(progress);\n        invalidate();\n    }\n\n    private void setCurrentProgress() {\n        if (currentProgress &lt; paddingLeft) {\n            currentProgress = paddingLeft;\n        }\n        //如果当前进度大于宽度-右边距\n        else if (currentProgress &gt; width - paddingRight) {\n            currentProgress = width - paddingRight;\n        }\n    }\n\n    //当前选中进度的回调\n    private OnProgressListener onProgressListener;\n\n    public interface OnProgressListener {\n        void onSelect(int progress);\n    }\n\n    public void setOnProgressListener(OnProgressListener onProgressListener) {\n        this.onProgressListener = onProgressListener;\n    }\n}\n\n</code></pre>\n<blockquote>\n<p>在Actiivty中去使用</p>\n</blockquote>\n<pre><code class=\"language-java\">/**\n * Created by 舍长\n * describe:最简单的进度条\n */\npublic class EasyActivity extends AppCompatActivity {\n\n    //进度条\n    @BindView(R.id.easyProgress)\n    EasyProgress easyProgress;\n\n    //当前进度条的百分比文本\n    @BindView(R.id.tvCurrentProgress)\n    TextView tvCurrentProgress;\n\n    //增加进度按钮\n    @BindView(R.id.faButton)\n    FloatingActionButton faButton;\n\n    //每次累加的进度\n    private int progress = 0;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_easy);\n        ButterKnife.bind(this);\n        tvCurrentProgress.setVisibility(View.VISIBLE);\n        faButton.setVisibility(View.VISIBLE);\n        //监听数值的变化\n        easyProgress.setOnProgressListener(new EasyProgress.OnProgressListener() {\n            @Override\n            public void onSelect(int progress) {\n                tvCurrentProgress.setText(progress + &quot;/100&quot;);\n//                L.d(&quot;progress:&quot;+progress);\n            }\n        });\n        //设置进度值\n        faButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (progress &lt; 100) {\n                    progress += 10;\n                    easyProgress.setProgress(progress);\n                } else {\n                    progress = 0;\n                }\n            }\n        });\n    }\n\n}\n</code></pre>\n<p>到这里你可能会说，就这么一点效果，弄得这么麻烦，我继承个SeekBar，重写几个属性不是美滋滋？确实，就当前的效果来说继承个Seekbar就可以了，但是现在你的UI表示，我想要你在进度条下面给我来个同步移动的文字！如下</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-3c16c66b9aebfd16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"进度条下方的文字.png\"></p>\n<blockquote>\n<p>加入你是使用的Seekbar，那么你已经凉了，没法判断圆点坐标的位置啊！（或者是我不知道？！），而这个效果也是我下一篇想要写的效果</p>\n</blockquote>\n','<p>Android自定义评View实例教程~自定义可拖拽进度条</p>\n',0),(10,'Android常用工具类的封装','Android常用工具类的封装','> 相关代码已上传至Github的Util文件夹内\n>\n> https://github.com/13531982270/BlogDemo\n\n### Log封装类\n\n> 为什么要封装Log，这是因为我们每次输入Log的时候，每次都要输入TAG，例如这样：\n\n```\n    Log.d(\"tonjie\",\"要输出的内容\");\n```\n\n\n\n> 很多时候我都是调试完程序，在程序没有问题的情况下就把Log删除的，所以练习时的简便就是我需要的，那么废话不多说，直接看代码吧！\n\n\n\n```\npublic class L {\n\n    //TAG\n    public static String TAG = \"tonjies\";\n\n    //5个等级 DIWE\n\n    public static void d(String text) {\n        Log.d(TAG, text + \"\");\n    }\n\n    public static void i(String text) {\n        Log.i(TAG, text + \"\");\n    }\n\n    public static void w(String text) {\n        Log.w(TAG, text + \"\");\n    }\n\n    public static void e(String text) {\n        Log.e(TAG, text + \"\");\n    }\n\n}\n```\n\n> 怎么样，相当简单的代码吧！我们只是把每次都要输入的TAG，提取出来，并把该值设置成默认的值罢了，让我们来看看怎么使用\n\n```java\n//┏┓　　　┏┓\n//┏┛┻━━━┛┻┓\n//┃　　　　　　　┃ 　\n//┃　　　━　　　┃\n//┃　┳┛　┗┳　┃\n//┃　　　　　　　┃\n//┃　　　┻　　　┃\n//┃　　　　　　　┃\n//┗━┓　　　┏━┛\n//┃　　　┃  神兽保佑　　　　　　　　\n//┃　　　┃  代码无BUG！\n//┃　　　┗━━━┓\n//┃　　　　　　　┣┓\n//┃　　　　　　　┏┛\n//┗┓┓┏━┳┓┏┛\n// ┃┫┫　┃┫┫\n//\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        L.d(\"log打印成功\");\n    }\n}\n```\n\n> 我们输入L.d(\"你好，世界\")，运行程序，输入tonjies，观察Logo，果然成功了，怎么样，只输入两个字母的Log是不是稍微方便一点了\n\n![输出Log](https://blogimg-1253839243.cos.ap-nanjing.myqcloud.com/one.png)\n\n> 这样封装可能会出现一个问题，就是在不经意用了太多的L工具类，导致输出的东西太乱，这时候我们可以选中L类，右键Find Usages，或者使用快捷键Alt+F7，在下边的find窗口查看我们都在哪里使用过，把不需要的注释或者删除掉\n\n![在哪里被使用.gif](https://blogimg-1253839243.cos.ap-nanjing.myqcloud.com/two.gif)\n\n\n### sharedPreferences封装类：\n\n> 关于SharedPreferences的用法就不赘述了，详情请查看[第一行代码](https://item.jd.com/12012505.html)第6.4节，强烈推荐使用科学的方法查看数据库文件，如facebook的[stetho](https://www.jianshu.com/p/03da9f91f41f)，这里封装的目的和封装Log一样，同样是为了简化操作，让我们先来看看原本的用法\n\n- 存数据:\n\n\n```java\nSharedPreferences.Editor editor=getSharedPreferences(\"data\",MODE_PRIVATE).edit();\neditor.putString(\"name\",\"tonjies\");\neditor.putInt(\"age\",20);\neditor.apply();\n```\n\n- 取数据：\n\n\n```java\nSharedPreferences preferences = getSharedPreferences(\"data\", MODE_PRIVATE);\nString name = preferences.getString(\"name\", \"\");\nint age = preferences.getInt(\"age\", 18);\nL.d(\"name:\" + name);\nL.d(\"age\" + age);\n```\n\n> 使用[stetho](https://www.jianshu.com/p/03da9f91f41f)工具查看：\n\n![stetho工具](https://blogimg-1253839243.cos.ap-nanjing.myqcloud.com/three.png)\n\n> 封装类：\n>\n\n```java\n\n/**\n * Created by 舍长 on 2018/2/10.\n * SharedPreferences 封装类\n */\n\npublic class ShareUtils {\n\n    public static final String NAME = \"config\";\n\n\n    /**\n     * 存储String类型的值\n     * @param mContext this\n     * @param key      key值\n     * @param value    要存储的String值\n     */\n    public static void putString(Context mContext, String key, String value) {\n        SharedPreferences sharedPreferences = mContext.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        sharedPreferences.edit().putString(key, value).commit();\n    }\n\n    /**\n     * 获取String类型的值\n     * @param mContext this\n     * @param key      key\n     * @param defValue 默认值\n     * @return\n     */\n    public static String getString(Context mContext, String key, String defValue) {\n        SharedPreferences sharedPreferences = mContext.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        return sharedPreferences.getString(key, defValue);\n    }\n\n\n    /**\n     * 存储Int类型的值\n     * @param mContext this\n     * @param key      key\n     * @param value    要存储的Int值\n     */\n    public static void putInt(Context mContext, String key, int value) {\n        SharedPreferences sharedPreferences = mContext.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        sharedPreferences.edit().putInt(key, value).commit();\n    }\n\n\n    /**\n     * 获取Int类型的值\n     * @param mContext this\n     * @param key      key\n     * @param defValue 默认值\n     * @return\n     */\n    public static int getInt(Context mContext, String key, int defValue) {\n        SharedPreferences sharedPreferences = mContext.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        return sharedPreferences.getInt(key, defValue);\n    }\n\n\n    /**\n     * 存储Boolean类型的值\n     * @param mContext this\n     * @param key      key\n     * @param value    要存储Boolean值\n     */\n    public static void putBoolean(Context mContext, String key, boolean value) {\n        SharedPreferences sharedPreferences = mContext.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        sharedPreferences.edit().putBoolean(key, value).commit();\n    }\n\n    /**\n     * 获取Boolean类型的值\n     * @param mContext this\n     * @param key      key\n     * @param defValue 默认值\n     * @return\n     */\n    public static boolean getBoolean(Context mContext, String key, Boolean defValue) {\n        SharedPreferences sharedPreferences = mContext.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        return sharedPreferences.getBoolean(key, defValue);\n    }\n\n    //删除 单个 key\n    public static void deleShare(Context context, String key) {\n        SharedPreferences sharedPreferences = context.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        sharedPreferences.edit().remove(key).commit();\n    }\n\n    //删除全部 key\n    public static void deleAll(Context context) {\n        SharedPreferences sharedPreferences = context.getSharedPreferences(NAME, Context.MODE_PRIVATE);\n        sharedPreferences.edit().clear().commit();\n    }\n}\n\n```\n> 我们把可复用的SharedPreferences类名和方法提取出来，并把不同的context对象，想要存储的值 ，想要去除去除的key字段值 ，  默认值等传入，看看具体的用法吧！\n\n- 存数据：\n\n\n```java\n//取出String类型\nfinal String string = ShareUtils.getString(ShareActivity.this, \"name\", \"没有值可以取出来\");\n L.d(string);\n```\n\n- 取数据：\n\n\n```java\n//取出int类型\nfinal int age2= ShareUtils.getInt(ShareActivity.this, \"age\", 18);\nL.d(age2+\"\");\n```\n\n\n\n### 自定义字体封装类：\n\n> 老规矩了，先看看原本应该如何实现\n\n在src-main-asset(需要自己创建)-fonts(自己创建)-添加字体-MengYuanti.ttf\n\n```java\nprivate void type() {\n     Typeface typeface=Typeface.createFromAsset(getAssets(),\"fonts/MengYuanti.ttf\");\n     txtB.setTypeface(typeface);\n }\n```\n\n![添加字体文件](http://upload-images.jianshu.io/upload_images/4002920-6bc54125178df52c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n封装类：\n\n```java\n/**\n * Created by 舍长 on 2018/4/27.\n */\n\npublic class FontSetting {\n    public FontSetting() {\n    }\n\n    public static void setFont(Context context, TextView textView, String fontsPath) {\n        try {\n            Typeface fromAsset = Typeface.createFromAsset(context.getAssets(), fontsPath);\n            textView.setTypeface(fromAsset);\n        } catch (Exception e) {\n            L.d(\"找不到文件资源！\");\n            Toast.makeText(context, \"服务器出错啦！\", Toast.LENGTH_SHORT).show();\n        }\n    }\n}\n\n```\n\n\n> 我们添加了setFont方法，并try...catch了一下，为什么要进行异常处理呢，因为如果我们的fontPath路径fontsPath错误了，比如\"fonts/MengYuanti.ttf\"变为了\"fonts/engYuanti.ttf\"，程序会跑出java.lang.RuntimeException:异常，程序会崩溃、所以我们进行异常捕获，并且告诉用户，是服务器出现了异常，这样用户的投诉就会让服务器人员去背，完美！\n\n![Logo.jpg](https://upload-images.jianshu.io/upload_images/4002920-104373d905f10ac2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n具体使用：\n\n```java\n/**\n * Created by 舍长 on 2018/4/5.\n * 描述: Android字体设置\n */\n\npublic class FontActivity extends WinBaseActivity {\n    @BindView(R.id.txt_01)\n    TextView txt01;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.switch_item_layout);\n        ButterKnife.bind(this);\n        FontSetting.setFont(FontActivity.this,txt01,\"fonts/chuxintech.woff\");\n    }\n}\n```\n\n\n\n> 好了，这三个小工具类就实现到这里了，相关代码已经上传到Github仓库的[Util文件夹](https://github.com/13531982270/BlogDemo)了，如果关于本篇文章有什么疑问，欢迎留言，感谢您的观看。\n>\n',1630684800,'<blockquote>\n<p>相关代码已上传至Github的Util文件夹内</p>\n<p><a href=\"https://github.com/13531982270/BlogDemo\">https://github.com/13531982270/BlogDemo</a></p>\n</blockquote>\n<a id=\"toc31\" href=\"#toc31\" class=\"anchor-fix\"><h3>Log封装类</h3></a>\n<blockquote>\n<p>为什么要封装Log，这是因为我们每次输入Log的时候，每次都要输入TAG，例如这样：</p>\n</blockquote>\n<pre><code>    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>d(<span class=\"hljs-string\">\"tonjie\"</span>,<span class=\"hljs-string\">\"要输出的内容\"</span>);</code></pre><blockquote>\n<p>很多时候我都是调试完程序，在程序没有问题的情况下就把Log删除的，所以练习时的简便就是我需要的，那么废话不多说，直接看代码吧！</p>\n</blockquote>\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">L</span> {</span>\n\n    <span class=\"hljs-comment\">//TAG</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">String</span> TAG = <span class=\"hljs-string\">\"tonjies\"</span>;\n\n    <span class=\"hljs-comment\">//5个等级 DIWE</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-built_in\">text</span>)</span> </span>{\n        Log.d(TAG, <span class=\"hljs-built_in\">text</span> + <span class=\"hljs-string\">\"\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">i</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-built_in\">text</span>)</span> </span>{\n        Log.i(TAG, <span class=\"hljs-built_in\">text</span> + <span class=\"hljs-string\">\"\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">w</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-built_in\">text</span>)</span> </span>{\n        Log.w(TAG, <span class=\"hljs-built_in\">text</span> + <span class=\"hljs-string\">\"\"</span>);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">e</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-built_in\">text</span>)</span> </span>{\n        Log.e(TAG, <span class=\"hljs-built_in\">text</span> + <span class=\"hljs-string\">\"\"</span>);\n    }\n\n}</code></pre><blockquote>\n<p>怎么样，相当简单的代码吧！我们只是把每次都要输入的TAG，提取出来，并把该值设置成默认的值罢了，让我们来看看怎么使用</p>\n</blockquote>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//┏┓　　　┏┓</span>\n<span class=\"hljs-comment\">//┏┛┻━━━┛┻┓</span>\n<span class=\"hljs-comment\">//┃　　　　　　　┃ 　</span>\n<span class=\"hljs-comment\">//┃　　　━　　　┃</span>\n<span class=\"hljs-comment\">//┃　┳┛　┗┳　┃</span>\n<span class=\"hljs-comment\">//┃　　　　　　　┃</span>\n<span class=\"hljs-comment\">//┃　　　┻　　　┃</span>\n<span class=\"hljs-comment\">//┃　　　　　　　┃</span>\n<span class=\"hljs-comment\">//┗━┓　　　┏━┛</span>\n<span class=\"hljs-comment\">//┃　　　┃  神兽保佑　　　　　　　　</span>\n<span class=\"hljs-comment\">//┃　　　┃  代码无BUG！</span>\n<span class=\"hljs-comment\">//┃　　　┗━━━┓</span>\n<span class=\"hljs-comment\">//┃　　　　　　　┣┓</span>\n<span class=\"hljs-comment\">//┃　　　　　　　┏┛</span>\n<span class=\"hljs-comment\">//┗┓┓┏━┳┓┏┛</span>\n<span class=\"hljs-comment\">// ┃┫┫　┃┫┫</span>\n<span class=\"hljs-comment\">//</span>\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> void onCreate(<span class=\"hljs-type\">Bundle</span> savedInstanceState) {\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n        setContentView(<span class=\"hljs-type\">R</span>.layout.activity_main);\n        <span class=\"hljs-type\">L</span>.d(<span class=\"hljs-string\">\"log打印成功\"</span>);\n    }\n}</code></pre>\n<blockquote>\n<p>我们输入L.d(&quot;你好，世界&quot;)，运行程序，输入tonjies，观察Logo，果然成功了，怎么样，只输入两个字母的Log是不是稍微方便一点了</p>\n</blockquote>\n<p><img src=\"https://blogimg-1253839243.cos.ap-nanjing.myqcloud.com/one.png\" alt=\"输出Log\"></p>\n<blockquote>\n<p>这样封装可能会出现一个问题，就是在不经意用了太多的L工具类，导致输出的东西太乱，这时候我们可以选中L类，右键Find Usages，或者使用快捷键Alt+F7，在下边的find窗口查看我们都在哪里使用过，把不需要的注释或者删除掉</p>\n</blockquote>\n<p><img src=\"https://blogimg-1253839243.cos.ap-nanjing.myqcloud.com/two.gif\" alt=\"在哪里被使用.gif\"></p>\n<a id=\"toc32\" href=\"#toc32\" class=\"anchor-fix\"><h3>sharedPreferences封装类：</h3></a>\n<blockquote>\n<p>关于SharedPreferences的用法就不赘述了，详情请查看<a href=\"https://item.jd.com/12012505.html\">第一行代码</a>第6.4节，强烈推荐使用科学的方法查看数据库文件，如facebook的<a href=\"https://www.jianshu.com/p/03da9f91f41f\">stetho</a>，这里封装的目的和封装Log一样，同样是为了简化操作，让我们先来看看原本的用法</p>\n</blockquote>\n<ul>\n<li>存数据:</li>\n</ul>\n<pre><code class=\"language-java\">SharedPreferences.Editor <span class=\"hljs-keyword\">editor</span>=getSharedPreferences(<span class=\"hljs-string\">\"data\"</span>,MODE_PRIVATE).edit();\n<span class=\"hljs-keyword\">editor</span>.putString(<span class=\"hljs-string\">\"name\"</span>,<span class=\"hljs-string\">\"tonjies\"</span>);\n<span class=\"hljs-keyword\">editor</span>.putInt(<span class=\"hljs-string\">\"age\"</span>,<span class=\"hljs-number\">20</span>);\n<span class=\"hljs-keyword\">editor</span>.apply();</code></pre>\n<ul>\n<li>取数据：</li>\n</ul>\n<pre><code class=\"language-java\">SharedPreferences preferences = get<span class=\"hljs-constructor\">SharedPreferences(<span class=\"hljs-string\">\"data\"</span>, MODE_PRIVATE)</span>;\nString name = preferences.get<span class=\"hljs-constructor\">String(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"\"</span>)</span>;\n<span class=\"hljs-built_in\">int</span> age = preferences.get<span class=\"hljs-constructor\">Int(<span class=\"hljs-string\">\"age\"</span>, 18)</span>;\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">L</span>.</span></span>d(<span class=\"hljs-string\">\"name:\"</span> + name);\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">L</span>.</span></span>d(<span class=\"hljs-string\">\"age\"</span> + age);</code></pre>\n<blockquote>\n<p>使用<a href=\"https://www.jianshu.com/p/03da9f91f41f\">stetho</a>工具查看：</p>\n</blockquote>\n<p><img src=\"https://blogimg-1253839243.cos.ap-nanjing.myqcloud.com/three.png\" alt=\"stetho工具\"></p>\n<blockquote>\n<p>封装类：</p>\n</blockquote>\n<pre><code class=\"language-java\">\n<span class=\"hljs-comment\">/**\n * Created by 舍长 on 2018/2/10.\n * SharedPreferences 封装类\n */</span>\n\npublic <span class=\"hljs-keyword\">class</span> ShareUtils {\n\n    public static final String NAME = <span class=\"hljs-string\">\"config\"</span>;\n\n\n    <span class=\"hljs-comment\">/**\n     * 存储String类型的值\n     * @param mContext this\n     * @param key      key值\n     * @param value    要存储的String值\n     */</span>\n    public static void put<span class=\"hljs-constructor\">String(Context <span class=\"hljs-params\">mContext</span>, String <span class=\"hljs-params\">key</span>, String <span class=\"hljs-params\">value</span>)</span> {\n        SharedPreferences sharedPreferences = mContext.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        sharedPreferences.edit<span class=\"hljs-literal\">()</span>.put<span class=\"hljs-constructor\">String(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">value</span>)</span>.commit<span class=\"hljs-literal\">()</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 获取String类型的值\n     * @param mContext this\n     * @param key      key\n     * @param defValue 默认值\n     * @return\n     */</span>\n    public static String get<span class=\"hljs-constructor\">String(Context <span class=\"hljs-params\">mContext</span>, String <span class=\"hljs-params\">key</span>, String <span class=\"hljs-params\">defValue</span>)</span> {\n        SharedPreferences sharedPreferences = mContext.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        return sharedPreferences.get<span class=\"hljs-constructor\">String(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">defValue</span>)</span>;\n    }\n\n\n    <span class=\"hljs-comment\">/**\n     * 存储Int类型的值\n     * @param mContext this\n     * @param key      key\n     * @param value    要存储的Int值\n     */</span>\n    public static void put<span class=\"hljs-constructor\">Int(Context <span class=\"hljs-params\">mContext</span>, String <span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">value</span>)</span> {\n        SharedPreferences sharedPreferences = mContext.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        sharedPreferences.edit<span class=\"hljs-literal\">()</span>.put<span class=\"hljs-constructor\">Int(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">value</span>)</span>.commit<span class=\"hljs-literal\">()</span>;\n    }\n\n\n    <span class=\"hljs-comment\">/**\n     * 获取Int类型的值\n     * @param mContext this\n     * @param key      key\n     * @param defValue 默认值\n     * @return\n     */</span>\n    public static <span class=\"hljs-built_in\">int</span> get<span class=\"hljs-constructor\">Int(Context <span class=\"hljs-params\">mContext</span>, String <span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">defValue</span>)</span> {\n        SharedPreferences sharedPreferences = mContext.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        return sharedPreferences.get<span class=\"hljs-constructor\">Int(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">defValue</span>)</span>;\n    }\n\n\n    <span class=\"hljs-comment\">/**\n     * 存储Boolean类型的值\n     * @param mContext this\n     * @param key      key\n     * @param value    要存储Boolean值\n     */</span>\n    public static void put<span class=\"hljs-constructor\">Boolean(Context <span class=\"hljs-params\">mContext</span>, String <span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">value</span>)</span> {\n        SharedPreferences sharedPreferences = mContext.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        sharedPreferences.edit<span class=\"hljs-literal\">()</span>.put<span class=\"hljs-constructor\">Boolean(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">value</span>)</span>.commit<span class=\"hljs-literal\">()</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 获取Boolean类型的值\n     * @param mContext this\n     * @param key      key\n     * @param defValue 默认值\n     * @return\n     */</span>\n    public static boolean get<span class=\"hljs-constructor\">Boolean(Context <span class=\"hljs-params\">mContext</span>, String <span class=\"hljs-params\">key</span>, Boolean <span class=\"hljs-params\">defValue</span>)</span> {\n        SharedPreferences sharedPreferences = mContext.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        return sharedPreferences.get<span class=\"hljs-constructor\">Boolean(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">defValue</span>)</span>;\n    }\n\n    <span class=\"hljs-comment\">//删除 单个 key</span>\n    public static void dele<span class=\"hljs-constructor\">Share(Context <span class=\"hljs-params\">context</span>, String <span class=\"hljs-params\">key</span>)</span> {\n        SharedPreferences sharedPreferences = context.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        sharedPreferences.edit<span class=\"hljs-literal\">()</span>.remove(key).commit<span class=\"hljs-literal\">()</span>;\n    }\n\n    <span class=\"hljs-comment\">//删除全部 key</span>\n    public static void dele<span class=\"hljs-constructor\">All(Context <span class=\"hljs-params\">context</span>)</span> {\n        SharedPreferences sharedPreferences = context.get<span class=\"hljs-constructor\">SharedPreferences(NAME, Context.MODE_PRIVATE)</span>;\n        sharedPreferences.edit<span class=\"hljs-literal\">()</span>.clear<span class=\"hljs-literal\">()</span>.commit<span class=\"hljs-literal\">()</span>;\n    }\n}\n</code></pre>\n<blockquote>\n<p>我们把可复用的SharedPreferences类名和方法提取出来，并把不同的context对象，想要存储的值 ，想要去除去除的key字段值 ，  默认值等传入，看看具体的用法吧！</p>\n</blockquote>\n<ul>\n<li>存数据：</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//取出String类型</span>\nfinal String <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ShareUtils</span>.</span></span>get<span class=\"hljs-constructor\">String(ShareActivity.<span class=\"hljs-params\">this</span>, <span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"没有值可以取出来\"</span>)</span>;\n <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">L</span>.</span></span>d(<span class=\"hljs-built_in\">string</span>);</code></pre>\n<ul>\n<li>取数据：</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//取出int类型</span>\nfinal <span class=\"hljs-built_in\">int</span> age2= <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ShareUtils</span>.</span></span>get<span class=\"hljs-constructor\">Int(ShareActivity.<span class=\"hljs-params\">this</span>, <span class=\"hljs-string\">\"age\"</span>, 18)</span>;\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">L</span>.</span></span>d(age2+<span class=\"hljs-string\">\"\"</span>);</code></pre>\n<a id=\"toc33\" href=\"#toc33\" class=\"anchor-fix\"><h3>自定义字体封装类：</h3></a>\n<blockquote>\n<p>老规矩了，先看看原本应该如何实现</p>\n</blockquote>\n<p>在src-main-asset(需要自己创建)-fonts(自己创建)-添加字体-MengYuanti.ttf</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> void <span class=\"hljs-keyword\">type</span><span class=\"hljs-literal\">()</span> {\n     Typeface typeface=<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Typeface</span>.</span></span>create<span class=\"hljs-constructor\">FromAsset(<span class=\"hljs-params\">getAssets</span>()</span>,<span class=\"hljs-string\">\"fonts/MengYuanti.ttf\"</span>);\n     txtB.set<span class=\"hljs-constructor\">Typeface(<span class=\"hljs-params\">typeface</span>)</span>;\n }</code></pre>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4002920-6bc54125178df52c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加字体文件\"></p>\n<p>封装类：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * Created by 舍长 on 2018/4/27.\n */</span>\n\npublic <span class=\"hljs-keyword\">class</span> FontSetting {\n    public <span class=\"hljs-constructor\">FontSetting()</span> {\n    }\n\n    public static void set<span class=\"hljs-constructor\">Font(Context <span class=\"hljs-params\">context</span>, TextView <span class=\"hljs-params\">textView</span>, String <span class=\"hljs-params\">fontsPath</span>)</span> {\n        <span class=\"hljs-keyword\">try</span> {\n            Typeface fromAsset = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Typeface</span>.</span></span>create<span class=\"hljs-constructor\">FromAsset(<span class=\"hljs-params\">context</span>.<span class=\"hljs-params\">getAssets</span>()</span>, fontsPath);\n            textView.set<span class=\"hljs-constructor\">Typeface(<span class=\"hljs-params\">fromAsset</span>)</span>;\n        } catch (Exception e) {\n            <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">L</span>.</span></span>d(<span class=\"hljs-string\">\"找不到文件资源！\"</span>);\n            <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Toast</span>.</span></span>make<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">context</span>, <span class=\"hljs-string\">\"服务器出错啦！\"</span>, Toast.LENGTH_SHORT)</span>.show<span class=\"hljs-literal\">()</span>;\n        }\n    }\n}\n</code></pre>\n<blockquote>\n<p>我们添加了setFont方法，并try...catch了一下，为什么要进行异常处理呢，因为如果我们的fontPath路径fontsPath错误了，比如&quot;fonts/MengYuanti.ttf&quot;变为了&quot;fonts/engYuanti.ttf&quot;，程序会跑出java.lang.RuntimeException:异常，程序会崩溃、所以我们进行异常捕获，并且告诉用户，是服务器出现了异常，这样用户的投诉就会让服务器人员去背，完美！</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4002920-104373d905f10ac2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Logo.jpg\"></p>\n<p>具体使用：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * Created by 舍长 on 2018/4/5.\n * 描述: Android字体设置\n */</span>\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FontActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WinBaseActivity</span> </span>{\n    <span class=\"hljs-meta\">@BindView</span>(<span class=\"hljs-type\">R</span>.id.txt_01)\n    <span class=\"hljs-type\">TextView</span> txt01;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> void onCreate(<span class=\"hljs-meta\">@Nullable</span> <span class=\"hljs-type\">Bundle</span> savedInstanceState) {\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n        setContentView(<span class=\"hljs-type\">R</span>.layout.switch_item_layout);\n        <span class=\"hljs-type\">ButterKnife</span>.bind(<span class=\"hljs-keyword\">this</span>);\n        <span class=\"hljs-type\">FontSetting</span>.setFont(<span class=\"hljs-type\">FontActivity</span>.<span class=\"hljs-keyword\">this</span>,txt01,<span class=\"hljs-string\">\"fonts/chuxintech.woff\"</span>);\n    }\n}</code></pre>\n<blockquote>\n<p>好了，这三个小工具类就实现到这里了，相关代码已经上传到Github仓库的<a href=\"https://github.com/13531982270/BlogDemo\">Util文件夹</a>了，如果关于本篇文章有什么疑问，欢迎留言，感谢您的观看。</p>\n</blockquote>\n','<p>Android常用工具类的封装</p>\n',0);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-08-28 20:05:08
